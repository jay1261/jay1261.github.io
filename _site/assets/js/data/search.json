[
  
  {
    "title": "Java 문법 (14) - Object 클래스",
    "url": "/posts/Java-%EB%AC%B8%EB%B2%95-(14)-Object-%ED%81%B4%EB%9E%98%EC%8A%A4/",
    "categories": "Java, Java_Mid1",
    "tags": "Java",
    "date": "2024-04-11 00:00:00 +0900",
    





    
    "snippet": "Java 문법 (14) - Object 클래스java.lang 패키지자바가 기본으로 제공하는 라이브러리 중에 가장 기본이 되는 것이 java.lang 패키지 입니다. 자바 언어를 이루는 가장 기본이 되는 클래스들을 보관하는 패키지입니다. java.lang 패키지는 모든 자바 애플리케이션에 자동으로 임포트 되기 때문에 생략해도 됩니다.java.lang ...",
    "content": "Java 문법 (14) - Object 클래스java.lang 패키지자바가 기본으로 제공하는 라이브러리 중에 가장 기본이 되는 것이 java.lang 패키지 입니다. 자바 언어를 이루는 가장 기본이 되는 클래스들을 보관하는 패키지입니다. java.lang 패키지는 모든 자바 애플리케이션에 자동으로 임포트 되기 때문에 생략해도 됩니다.java.lang 패캐지의 대표적인 클래스들  Object: 모든 자바 객체의 부모 클래스  String: 문자열  Integer, Long, Double: 래퍼 타입, 기본형 데이터 타입을 객체로 만든 것  Class: 클래스 메타 정보  System: 시스템과 관련된 기본 기능들을 제공Object 클래스Object 예시자바에서 모든 클래스의 최상위 부모 클래스는 항상 Object 클래스입니다. 클래스에 상속 받을 부모 클래스가 없으면 묵시적으로 Object 클래스를 상속받게 됩니다.// Parent.java  // 부모가 없으면 묵시적으로 Object 클래스를 상속받는다.  // extends Object가 생략되어 있음  public class Parent {      public void parentMethod(){          System.out.println(\"Parent.parentMethod\");      }  }// Child.java// extends로 상속받는게 있으면 Object를 직접 상속받지 않음  public class Child extends Parent {        public void childMethod(){          System.out.println(\"Child.childMethod\");      }  }// ObjectMain.java  public class ObjectMain {      public static void main(String[] args) {          Child child = new Child();          child.parentMethod();          child.childMethod();            // toString()은 Object 클래스의 메서드          String string = child.toString();          System.out.println(string);      }  }Child는 Parent를 상속받고 Parent는 상속받는 코드가 없기 때문에 자동으로 Object를 상속받게 됩니다. Child -&gt; Parent -&gt; ObjectChild의 객체 child는 자신의 메서드인 childMethod()를 직접 호출 가능하고, 부모의 메서드 parentMethod()도 호출 가능하며, 조부모인 Object의 toString() 메서드 또한 호출 가능합니다.Object가 최상위 부모 클래스인 이유  공통 기능 제공          객체의 정보를 제공 toString()      객체의 같음을 비교 equals()      객체의 클래스 정보를 제공 getClass()        위와 같은 기능들은 모든 객체에게 필요한 기본 기능입니다. 이런 기능을 객체를 만들 때 마다 항상 새로운 메서드를 정의해야 한다면 상당히 번거로울 것입니다. 만든다고 해도 개발자마다 서로 다른 이름의 메서드를 만들게 될 것이고, 그렇다면 일관성이 없어져 호환성도 떨어집니다.        다형성의 기본 구현    Object는 모든 클래스의 부모 클래스이기 때문에 모든 객체를 참조할 수 있습니다. 이를 통해 Object 클래스는 다형성을 지원하는 기본적인 메커니즘을 제공합니다. 모든 자바 객체는 Object 타입으로 처리될 수 있고, 이는 다양한 타입의 객체를 통합적으로 처리할 수 있게 해줍니다. 예를들어 타입이 다른 객체들을 어딘가 한 곳에 보관해야 한다면 Object 배열에 보관할 수 있습니다.  Object 다형성 예제//Car.javapublic class Car {      public void move(){          System.out.println(\"자동차 이동\");      }  }// Dog.javapublic class Dog {      public void sound(){          System.out.println(\"멍멍\");      }  }ObjectPolyExample.java  public class ObjectPolyExample {      public static void main(String[] args) {          Dog dog = new Dog();          Car car = new Car();            // Object는 모든 객체의 부모이기 때문에 담을 수 있다.          action(dog);          action(car);          \t    // 오브젝트 배열에 자바의 모든 객체를 담을 수 있다\t    Object[] objects = {dog, car, object};\t    size(objects);    }        private static void action(Object obj){          // obj.move();  컴파일 오류 Object는 move()가 없음          // obj.sound();  컴파일 오류 Object는 sound()가 없음          // 객체에 맞는 다운 캐스팅이 필요          if (obj instanceof Dog dog) {              dog.sound();          } else if (obj instanceof Car car) {              car.move();          }      }          // Obbject 타입만 사용하는 메서드이기 때문에 자바를 사용하는 곳이라면 어디든지 사용될 수 있다.  \tprivate static void size(Object[] objects) {  \t    System.out.println(\"전달된 객체의 수는: \" + objects.length);  \t}}서로 전혀 관계가 없는 Car와 Dog클래스입니다. 둘 다 부모 클래스가 없기 때문에 Object를 자동으로 상속 받습니다.  Object는 모든 객체를 담을 수 있어서 함수 및 배열에 다른 타입의 객체들을 전부 담을 수 있습니다.  하지만 Object는 자식의 메서드를 알고 있지 않기 때문에, 자식 메서드를 호출하려면 다운 캐스팅을 해야합니다.toString()Object.toString() 메서드는 객체의 정보를 문자열 형태로 제공합니다. 그래서 디버깅과 로깅에 유용하게 사용되는 메서드입니다. 이 메서드는 Object 클래스에 정의되므로 모든 클래스에서 상속받아 사용할 수 있습니다.public String toString() {    return getClass().getName() + \"@\" + Integer.toHexString(hashCode());}toString() 메서드는 객체의 이름과 객체의 참조값(해시코드)를 16진수로 return합니다. System.out.println 과 출력 결과가 완전히 같은데, 이는 println 내부에서 toString을 호출하기 때문입니다.toString() 오버라이딩Object.toString() 메서드가 클래스 정보와  참조값을 제공하지만 이 정보만으로 객체의 상태를 적절히 표현하지는 못합니다. 그래서 보통 toString()을 오버라이딩해서 적절한 정보를 제공하는 것이 일반적입니다.//Dog.java  public class Dog {      private String dogName;      private int age;        public Dog(String dogName, int age) {          this.dogName = dogName;          this.age = age;      }      \t// toString 오버라이딩    @Override      public String toString() {          return \"Dog{\" +                  \"dogName='\" + dogName + '\\'' +                  \", age=\" + age +                  '}';      }  }//Car.java  public class Car {  \t// toString 오버라이딩 하지 않음    private String carName;        public Car(String carName) {          this.carName = carName;      }  }// ToStringMain2.javapublic class ToStringMain2 {      public static void main(String[] args) {          Car car = new Car(\"ModelY\");          Dog dog = new Dog(\"멍멍이1\", 2);          Dog dog2 = new Dog(\"멍멍이2\", 5);            System.out.println(\"1. 단순 toString 호출\");          System.out.println(car.toString());  // lang.object.tostring.Car@452b3a41        System.out.println(dog.toString());  //Dog{dogName='멍멍이1', age=2}        System.out.println(dog2.toString());  //Dog{dogName='멍멍이2', age=5}          System.out.println(\"2. println 내부에서 toString 호출\");          System.out.println(car);  //lang.object.tostring.Car@452b3a41        System.out.println(dog);  //Dog{dogName='멍멍이1', age=2}        System.out.println(dog2);  //Dog{dogName='멍멍이2', age=5}                 // 오버라이딩을 하면 객체의 참조값을 출력할 수 없다. 다음 코드를 사용하면 참조값 출력 가능하다         // System.identityHashcode()          System.out.println(System.identityHashCode(dog));          String refValue = Integer.toHexString(System.identityHashCode(dog));          System.out.println(refValue);      System.out.println(Integer.toBinaryString(System.identityHashCode(dog)));      }  }Dog에서 toString()을 오버라이딩한 예제입니다. toString()과 println의 결과가 똑같은데, 오버라이딩 된 함수가 잘 호출되는 것을 알 수 있습니다.toStirng()을 오버라이딩 하게되면 원래 보여주던 참조값을 더 이상 출력할 수 없게됩니다. 참조값이 필요한 경우에는 System.identityHashcode() 코드를 사용해서 참조값을 가져올 수 있습니다.equals()동일성과 동등성  동일성(Identity): == 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인  동등성(Equality): equals() 메서드를 사용하여 두 객체가 논리적으로 동등한지 확인\b쉽게 생각하면 동일성은 완전히 같음, 자바에서는 같은 메모리에 있는 객체 인스턴스인지 참조값을 확인하는 것이고, 동등성은 같은 가치나 수준, 보통 사람이 생각하는 논리적인 기준에 맞추어 비교합니다.User a = new User(\"id-100\")User b = new User(\"id-100\")a와 b 유저가 있을 때, 서로 다른 메모리에 존재하지만, 회원 번호 기준으로 생각해보면 논리적으로 같은 회원입니다. 이런 경우 동일성은 다르지만, 동등성은 같은 경우가 됩니다.Object.equals()Object가 기본으로 제공하는 equals()는 ==으로 동일성 비교를 합니다. 따라서 동등성 비교를 사용하고 싶다면 equals() 메서드를 오버라이딩 해야합니다.// User.javapublic class User {      private String id;        public User(String id) {          this.id = id;      }       // equals 오버라이딩     @Override      public boolean equals(Object object) {          if (this == object) return true;          if (object == null || getClass() != object.getClass()) return false;          User user = (User) object;          return Objects.equals(id, user.id);      }  }// EqualsMain.javapublic class EqualsMain {      public static void main(String[] args) {          User user1 = new User(\"id-100\");          User user2 = new User(\"id-100\");            System.out.println(\"identity = \" + (user1 == user2)); // false          // 오버라이딩 된 equalds() 사용          System.out.println(\"equality = \" + user1.equals(user2)); // true      }  }이렇게 equals를 오버라이딩해서 사용하면 user1, user2의 동일성과 동등성을 비교할 수 있습니다.equals() 메서드를 구현할 때 지켜야 하는 규칙  반사성: 객체는 자기 자신과 동등해야한다. (x.equals(x)는 항상 true)  대칭성: 두 객체가 서로에 대해 동일하다고 판단한다면, 이는 양방향으로 동일해야 한다. (x.equals(y)가 true이면, y.equals(x)도 true)  추이성: 만약 한 객체가 두 번째 객체와 동일하고, 두 번째 객체가 세 번째 객체와 동일하다면, 첫 번째 객체와 세번째 객체는 동일하다.  일관성: 두 객체의 상태가 변경되지 않는 한, equals() 메소드는 항상 같은 값을 반환해햐 한다.  null에 대한 비교: 모든 객체는 null과 비교했을 때 false를 반환해야 한다."
  },
  
  {
    "title": "Java 문법 (13) - 다형성과 설계",
    "url": "/posts/Java-%EB%AC%B8%EB%B2%95-(13)-%EB%8B%A4%ED%98%95%EC%84%B1%EA%B3%BC-%EC%84%A4%EA%B3%84/",
    "categories": "Java, Java_Basic",
    "tags": "Java",
    "date": "2024-04-10 00:00:00 +0900",
    





    
    "snippet": "Java 문법 (13) - 다형성과 설계좋은 객체지향 프로그래밍객체지향에는 추상화, 캡슐화, 상속, 다형성의 특징이 있는데 이 중 다형성이 가장 중요하다고 볼 수 있습니다. 객체지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 객체들의 모임으로 파악하고자 하는 것입니다. 각각의 객체들은 메시지를 주고받고...",
    "content": "Java 문법 (13) - 다형성과 설계좋은 객체지향 프로그래밍객체지향에는 추상화, 캡슐화, 상속, 다형성의 특징이 있는데 이 중 다형성이 가장 중요하다고 볼 수 있습니다. 객체지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 객체들의 모임으로 파악하고자 하는 것입니다. 각각의 객체들은 메시지를 주고받고 데이터를 처리할 수 있습니다.객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용됩니다. 마치 레고 블럭을 조립하듯이, 컴퓨터 부품을 갈아 끼우듯이 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법입니다.다형성역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해집니다.  클라이언트는 대상의 역할만 알면 됨  클라이언트는 구현 대상의 내부구조를 몰라도 됨  클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않음  클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않음이를 운전자와 자동차의 관계에 비유하면 다음과 같습니다.  운전자는 자동차의 역할만 알면 되고, 내부구조를 몰라도 됩니다.  자동차의 내부구조가 변경되어도 운전자는 영향을 받지 않습니다.  운전자는 차를 바꿔도 영향을 받지 않습니다.자바 언어에서는 역할 = 인터페이스 /  구현 = 인터페이스를 구현한 클래스, 구현 객체로 볼 수 있습니다. 객체 설계시 역할을 먼제 부여하고, 그 역할을 수행하는 구현 객체를 만들어야 합니다. 또한 객체의 협력이라는 관계를 생각해야합니다. 수많은 객체 클라이언트(요청)와 서버(응답)는 서로 협력 관계를 가집니다.다형성 - 역할과 구현 예제// Driver.java  public class Driver {      private Car car;        public void setCar(Car car){          this.car = car;      }        public void drive() {          System.out.println(\"자동차를 운전합니다\");          car.startEngine();          car.pressAccelerator();          car.offEnngine();      }  }// Car.javapublic interface Car {      void startEngine();      void pressAccelerator();      void offEnngine();  }// K3Car.javapublic class K3Car implements Car {      public void startEngine(){          System.out.println(\"K3Car.startEngine\");      }        public void offEnngine() {          System.out.println(\"K3Car.offEnngine\");      }        public void pressAccelerator(){          System.out.println(\"K3Car.pressAccelerator\");      }    }// Model3Car.java  public class Model3Car implements Car{      public void startEngine(){          System.out.println(\"Model3Car.startEngine\");      }        public void offEnngine() {          System.out.println(\"Model3Car.offEnngine\");      }        public void pressAccelerator(){          System.out.println(\"Model3Car.pressAccelerator\");      }    }// CarMain1.java  public class CarMain1 {      public static void main(String[] args) {          Driver driver = new Driver();          K3Car k3Car = new K3Car();            driver.setCar(k3Car);          driver.drive();            // 추가          Model3Car model3Car = new Model3Car();          driver.setCar(model3Car);          driver.drive();            NewCar newCar = new NewCar();          driver.setCar(newCar);          driver.drive();      }  }Driver는 Car의 역할에만 의존합니다. 구현인 K3와 Model3 자동차에는 의존하지 않습니다. 새로운 차량이 추가되어도 Dirver의 코드는 전혀 수정하지 않아도 됩니다. 이는 확장에 열려있고, 수정에는 닫혀있는 코드로 OCP원칙(Open-Closed Principle)을 잘 지키고 있는 코드라고 볼 수 있습니다."
  },
  
  {
    "title": "Java 문법 (12) - 다형성2",
    "url": "/posts/Java-%EB%AC%B8%EB%B2%95-(12)-%EB%8B%A4%ED%98%95%EC%84%B12/",
    "categories": "Java, Java_Basic",
    "tags": "Java",
    "date": "2024-04-09 00:00:00 +0900",
    





    
    "snippet": "Java 문법 (12) - 다형성2다형성 활용다형성을 사용하지 않은 코드다형성을 사용하지 않은 코드를 변경해서 다형성을 적용시켜보겠습니다. 단순한 동물 소리를 테스트하는 코드입니다.// Dog.javapackage poly.ex1;    public class Dog {      public void sound(){          System.out...",
    "content": "Java 문법 (12) - 다형성2다형성 활용다형성을 사용하지 않은 코드다형성을 사용하지 않은 코드를 변경해서 다형성을 적용시켜보겠습니다. 단순한 동물 소리를 테스트하는 코드입니다.// Dog.javapackage poly.ex1;    public class Dog {      public void sound(){          System.out.println(\"멍멍\");      }  }// Cat.javapackage poly.ex1;    public class Cat {      public void sound(){          System.out.println(\"야옹\");      }  }// AnimalSountMain.javapackage poly.ex1;    public class AnimalSountMain {      public static void main(String[] args) {          // 다형성이 없을 때 중복되는 코드들          Dog dog = new Dog();          Cat cat = new Cat();          \t\t// 중복되는 코드        System.out.println(\"동물소리 테스트 시작\");          dog.sound();          System.out.println(\"동물소리 테스트 종료\");            System.out.println(\"동물소리 테스트 시작\");          cat.sound();          System.out.println(\"동물소리 테스트 종료\");      }  }다형성을 사용하지 않으면 새로운 동물을 추가할 때, main에서 변경해야할 부분들이 많고, 중복되는 코드가 많습니다. 중복을 해결하고자 메서드, 반복문을 사용하려고 해도 타입이 다르기 때문에 사용할 수 없습니다.다형성 적용Animal 이라는 클래스를 만들어서 다형성을 사용해보겠습니다.// Animal.javapackage poly.ex2;    public class Animal {      // 동물은 추상적인 개념이라 실제 인스턴스가 생기는 것은 어색함.      // 따라서 추상 클래스가 필요로 함      public void sound(){          System.out.println(\"동물소리 테스트 시작\");      }  }// Dog.javapackage poly.ex2;    public class Dog extends Animal{      @Override      public void sound(){            System.out.println(\"멍멍\");      }  }package poly.ex2;    public class Cat extends Animal{      @Override      public void sound(){            System.out.println(\"야옹\");      }  }package poly.ex2;    public class AnimalSoundMain2 {      public static void main(String[] args) {  \t    // 새로운 동물도 new Caw()만 추가해주면 가능        Animal[] animals = {new Dog(), new Cat(), new Caw()};            for(Animal animal: animals){              soundAnimal(animal);          }      }        private static void soundAnimal(Animal animal){          System.out.println(\"동물소리 테스트 시작\");          animal.sound();          System.out.println(\"동물소리 테스트 종료\");      }  }다형성을 사용해서 Animal 이라는 부모 클래스를 만들어 타입을 같게 만들어 줌으로써 중복되는 코드들을 제거할 수 있습니다. 새로운 동물을 추가할 때에도 기존과 달리 main에서 객체만 생성해주면 됩니다.추상 클래스추상 클래스예제에서 Animal 클래스는 동물이라는 추상적인 개념입니다. 이 클래스를 직접 인스턴스를 생성해서 사용할 일은 없습니다. 따라서 인스턴스를 생성할 수 없게 제약을 주는 것이 추상 클래스입니다.추상 클래스는 클래스를 선언할 때 앞에 abstract 키워드를 붙여주면 됩니다. 기존 클래스와 완전히 같지만, 직접 인스턴스를 생성하지 못하는 제약만 추가된 클래스입니다. new AbstractAnimal()으로 인스턴스를 만들려고 하면 컴파일 오류가 발생합니다.추상 메서드부모 클래스를 상속받는 자식 클래스가 반드시 오버라이딩 해야 하는 메서드를 부모 클래스에 정의할 수 있습니다. 이를 추상 메서드라고 합니다.이름 그대로 추상적인 개념을 제공하는 메서드로, 실체가 존재하지 않아서 메서드 바디가 없습니다. 선언할 때 메서드 앞에 abstract 키워드를 붙여주면 됩니다.추상 클래스, 메서드 예제// AbstractAnimal.javapackage poly.ex3;      // 추상 클래스는 클래스에서 인스턴스를 생성하지 못한다는 제약이 추가되는 것public abstract class AbstractAnimal {      // 추상 메서드 :    // 바디를 가질 수 없음      // 추상 메서드를 하나라도 가지고 있으면 그 클래스도 추상 클래스여야 함      // 추상 메서드는 무조건 오버라이딩해야 함      // 오버라이딩 하지 않으면 자식도 추상 클래스가 되어야 함      public abstract void sound();        public void move(){          System.out.println(\"동물이 움직입니다.\");      }  }// Dog.javapackage poly.ex3;    public class Dog extends AbstractAnimal{  \t// 추상 메서드 오버라이딩    @Override      public void sound() {          System.out.println(\"멍멍\");      }  }순수 추상 클래스예제의 AbstractAnimal에서 move()도 추상 메서드로 만들게 되면, AbstractAnimal 클래스의 모든 메서드가 추상 메서드가 됩니다. 이런 클래스를 순수 추상 클래스라고 합니다. public abstract class AbstractAnimal {     public abstract void sound();     public abstract void move();}순수 추상 클래스는 코드를 실행할 바디 부분이 전혀 없습니다. 주로 다형성을 위한 부모 타입으로 껍데기 역할만 제공합니다. 상속시 자식은 모든 메서드를 오버라이딩 해야한다는 특징이 있는데, 어떤 규격을 지켜서 구현해야하는 것 처럼 느껴집니다.USB 인터페이스 처럼 규격을 맞추어 제품을 개발해야하는 것 처럼, 순수 추상 클래스를 USB 인터페이스 규격처럼 사용할 수 있습니다. 자바는 순수 추상 클래스를 더 편리하게 사용할 수 있도록 인터페이스라는 개념을 제공합니다.인터페이스인터페이스는 추상클래스의 특징에 더해서 편의 기능이 추가됩니다.  인스턴스를 생성할 수 없다  상속시 모든 메서드를 오버라이딩 해야 한다  주로 다형성을 위해 사용된다  인터페이스의 메서드는 모두 public, abstract이다.  메서드에 public abstract를 생략할 수 있다. 생략 권장  인터페이스는 다중 구현을 지원한다.  인터페이스의 멤버변수는 public static final이 모두 포함되었다고 간주한다. 생략가능 (상수)// InterfaceAnimal.javapublic interface InterfaceAnimal {     int MAX_COUNT = 100; // public static final 생략     void sound(); // public abstract 생략     void move(); // public abstract 생략 }// Dog.javapackage poly.interfaceEx1;    public class Dog implements InterfaceAnimal {      @Override      public void sound() {          System.out.println(\"멍멍\");      }        @Override      public void move() {          System.out.println(\"강아지가 움직입니다.\");      }  }인터페이스를 상속 받을 때는 extends 대신에 implements, 구현 이라는 키워드를 사용합니다. 상속은 부모의 기능을 물려받는 것이 목적이지만, 인터페이스는 물려받을 기능이 없고 모든 메서드를 오버라이딩 해서 기능을 구현해야 하기 때문에 구현이라고 표현합니다.인터페이스를 사용해야 하는 이유순수 추상 클래스를 만들어도 되고 인터페이스를 만들어도 되는데, 인터페이스를 사용하는 이유가 있습니다.  제약: 인터페이스를 만드는 이유는 인터페이스를 구현하는 곳에서 인터페이스의 메서드를 반드시 구현해라는 제약을 주는 것입니다. 순수 추상 클래스의 경우 미래에 누군가 그곳에 실행 가능한 메서드를 끼워 넣을 수 있습니다. 그렇게 되면 추가된 기능을 자식 클래스에서 구현하지 않을 수도 있고, 또한 더는 순수 추상 클래스가 아니게 됩니다. 인터페이스는 제약을 주어서 이러한 문제를 원천 차단합니다.  다중 구현: 자바에서 클래스 상속은 부모를 하나만 지정할 수 있습니다. 반면에 인터페이스는 부모를 여러명 두는 다중 구현이 가능합니다.인터페이스 다중 구현자바가 다중 상속을 지원하지 않는 이유다이아몬드 문제 때문입니다. 만약 Airplane과 Car를 상속 받는 AirplaneCar라는 클래스가 있을 때, Airplane과 Car 모두 move()라는 기능을 가지고 있다면, AirplaneCar 입장에서 move를 호출할 때 어떤 부모의 move를 사용해야 할지 애매한 문제가 발생합니다. 이를 다이아몬드 문제라고 합니다.인터페이스 다중 구현을 지원하는 이유인터페이스는 모두 추상 메서드로 이루어져 있기 때문입니다. InterfaceA, InterfaceB 모두 method()라는 같은 함수를 가지고 있고, Child는 두 인터페이스를 모두 구현합니다. 이 때 Child입장에서 method()를 불러도 어차피 오버라이딩에 의해서 Child에서 구현한 method()가 호출되기 때문에 문제가 발생하지 않습니다.// InterfaceA.javapublic interface InterfaceA {      void method();      void methodA();  }// InterfaceB.javapublic interface InterfaceB {      void method();      void methodB();  }// Child.java public class Child implements InterfaceA, InterfaceB {      @Override      public void methodA() {          System.out.println(\"Child.methodA\");      }        @Override      public void methodB() {          System.out.println(\"Child.methodB\");      }  \t// 오버라이딩으로 Child의 method가 우선순위를 갖기 때문에 문제되지 않음    @Override      public void method() {          System.out.println(\"Child.methodCommon\");      }  }클래스 상속 + 인터페이스 구현public class Child extends ParentsClass implements InterfaceA, InterfaceB{}exdends를 통한 상속은 하나만 할 수 있고, implements를 통한 인터페이스는 다중 구현할 수 있습니다. 둘이 함께 나온 경우 extends가 먼저 나와야 합니다."
  },
  
  {
    "title": "Java 문법 (11) - 다형성1",
    "url": "/posts/Java-%EB%AC%B8%EB%B2%95-(11)-%EB%8B%A4%ED%98%95%EC%84%B11/",
    "categories": "Java, Java_Basic",
    "tags": "Java",
    "date": "2024-04-08 00:00:00 +0900",
    





    
    "snippet": "Java 문법 (11) - 다형성1\b다형성다형성은 이름 그대로 “다양한 형태”, “여러 형태”를 뜻합니다.프로그래밍에서 다형성은 한 객체가 여러 타입의 객체로 취급될 수 있는 능력을 말합니다. 보통 하나의 객체는 하나의 타입으로 고정되어 있습니다. 그런데 다형성을 사용하면 하나의 객체가 다른 타입으로 사용될 수 있습니다.다형성을 이해하기 위해서는 다형...",
    "content": "Java 문법 (11) - 다형성1\b다형성다형성은 이름 그대로 “다양한 형태”, “여러 형태”를 뜻합니다.프로그래밍에서 다형성은 한 객체가 여러 타입의 객체로 취급될 수 있는 능력을 말합니다. 보통 하나의 객체는 하나의 타입으로 고정되어 있습니다. 그런데 다형성을 사용하면 하나의 객체가 다른 타입으로 사용될 수 있습니다.다형성을 이해하기 위해서는 다형적 참조, 메서드 오버라이딩 2가지 핵심 이론을 알아야합니다.다형적 참조// Parent.javapackage poly.Basic;    public class Parent {      public void parentMethod(){          System.out.println(\"parent.parentMethod\");      }  }// Child.javapackage poly.Basic;    public class Child extends Parent{      public void childMethod(){          System.out.println(\"child.childMethod\");      }  }// PolyMain.javapackage poly.Basic;    public class PolyMain {      public static void main(String[] args) {          // (1) 부모 변수가 부모 인스턴스 참조          System.out.println(\"Parent -&gt; Parent\");          Parent parent = new Parent();          parent.parentMethod();            // (2) 자식 변수가 자식 인스턴스 참조          Child child = new Child();          child.childMethod();          child.parentMethod();            // (3) 부모 변수가 자식 인스턴스 참조 (다형적 참조)          Parent poly = new Child();          poly.parentMethod();  \t\t// pChild.childMethod(); 자식 메서드 호출 불가능  \t}  }다형적 참조를 이해하기 위한 예제코드입니다. Child 클래스는 Parent 클래스를 상속받았고 PolyMain에서 사용됩니다.(1) 부모 변수가 부모 인스턴스 참조Parent parent = new Parent();이 경우 부모타입인 Parent를 생성했기 때문에, 메모리 상에 Parent만 생성됩니다 (자식은 생성되지 않습니다).생성된 참조값을 Parent타입 변수인 parent에 담아두고 parent.ParentMethod()를 호출하면 Parent클래스에 있는 parentMethod()가 호출됩니다.(2) 자식 타입의 변수가 자식 인스턴스 참조Child child = new Child();이 경우 자식 타입인 Child를 생성했기 때문에 메모리상에 Child와 Parent가 모두 생성됩니다.생성된 참조값을 Child 타입의 변수인 child에 담아둡니다.child.childMethod()를 호출하면 인스턴스의 Child 클래스에 있는 childMethod()가 호출됩니다.(3) 다형적 참조: 부모 타입의 변수가 자식 인스턴스 참조Parent poly = new Child();Child 인스턴스를 생성했기 때문에 메모리상에 Child와 Parent가 모두 생성됩니다.생성된 참조값을 Parent 타입의 변수인 poly에 담아둡니다.여기서 poly는 Parent(부모)타입이고, 생성된 인스턴스는 Child타입입니다. 자바에서 부모타입은 자식 타입을 담을 수 있습니다. Parent poly = new Child(); (가능)반대로 자식 타입은 부모 타입을 담을 수 없습니다. Child child1 = new Parent(); (불가능)다형성과 캐스팅package poly.Basic;    public class CastingMain {      public static void main(String[] args) {          Parent poly = new Child();          poly.parentMethod();          //poly.childMethod():            // 다운 캐스팅 가능         Child child = (Child) poly;          child.childMethod();            // 일시적 다운 캐스팅          ((Child) poly).childMethod();\t\t// 업캐스팅\t\tChild child1 = new Child();\t\tParent parent1 = (Parent) child1; // 업캐스팅은 생략가능, 생략 권장\t\tParent parent2 = child1 // 업캐스팅 생략    }  }Parent poly = new Child() 와 같이 부모 타입의 변수를 사용하게 되면 poly.childMethod() 와 같이 자식 타입에 있는 기능은 호출할 수 없습니다. 이럴 때에는 다운캐스팅을 사용할 수 있습니다.Child child = (Child) poly; 일반 타입을 캐스팅 하는 것 처럼 코드를 작성하면 캐스팅이 됩니다. 다운캐스팅 된 변수는 childMethod를 호출할 수 있게됩니다.반대로 Child 타입을 Parent 타입으로 캐스팅할 수도 있습니다. 이를 업캐스팅이라고 합니다.다운캐스팅 주의점업캐스팅과 다르게 다운캐스팅은 주의할 점이 있습니다. 바로 자식의 인스턴스가 생성되지 않았는데 캐스팅하는 경우로 코드로 보면 다음과 같습니다.parent변수는 Parent 인스턴스를 생성했습니다. 즉, Child는 생성되지 않은 상태입니다. 이렇게 메모리에 존재하지 않는 Child로 캐스팅하려고 하면 심각한 런타입 오류가 발생합니다.package poly.Basic;    public class CastingMain {      public static void main(String[] args) {          Parent parent = new Parent();          Child child = (Child) parent;    }  }instanceof다형성에서 참조형 변수는 다양한 자식을 대상으로 참조할 수 있습니다. 그런데 참조하는 대상이 다양하기 때문에 어떤 인스턴스를 참조하고 있는지 확인하고 싶다면 instanceof를 사용해 확인할 수 있습니다.if (parent instanceof Child) parent변수가 Child의 인스턴스라면 true, 아니라면 false를 반환해서 확인할 수 있습니다.자바 16부터는 instanceof를 사용하면서 동시에 변수를 선언할 수 있습니다.package poly.Basic;    public class CastingMain5 {      public static void main(String[] args) {          Parent parent1 = new Parent();          call(parent1);            Parent parent2 = new Child();          call(parent2);        }        private static void call(Parent parent){          // instanceof          if (parent instanceof Child){              System.out.println(\"Child 인스턴스 맞음\");              Child child = (Child) parent;              child.childMethod();          }          else {              System.out.println(\"Child 인스턴스 아님\");          }                  // java16 부터 가능. instaceof 사용하면서 변수 선언         if(parent instanceof Child child){\t        child.childMethod();        }    }  }다형성과 메서드 오버라이딩다형성을 이루는 또 하나의 중요한 핵심 이론인 메서드 오버라이딩입니다.메서드 오버라이딩에서 꼭 기억해야 할 점은 오버라이딩 된 메서드가 항상 우선권을 가진다는 점입니다.// Parent.javapackage poly.overriding;    public class Parent {      public String value = \"parent\";        public void method(){          System.out.println(\"Parent.method\");      }  }// Child.javapackage poly.overriding;    public class Child extends Parent{      public String value = \"child\";        @Override      public void method() {          System.out.println(\"Child.metohd\");      }  }package poly.overriding;    public class OverridingMain {      public static void main(String[] args) {          // 부모 변수가 자식 인스턴스를 참조(다형적 참조)          Parent poly = new Child();          System.out.println(\"Parent -&gt; Child\");          System.out.println(\"value = \" + poly.value); // 변수는 오버라이딩 x                poly.method();  // 메서드는 오버라이딩 o      }  }poly는 Child 인스턴스를 업캐스팅한 Parent타입입니다.poly.value 변수는 Parent타입에 있는 value값을 읽어옵니다.poly.method()는 Parent타입에 있는 method를 실행하지않고, Child에 오버라이딩된 메서드가 항상 우선권을 갖기 때문에 Child.method()가 실행됩니다."
  },
  
  {
    "title": "Java 문법 (10) - 상속",
    "url": "/posts/Java-%EB%AC%B8%EB%B2%95-(10)-%EC%83%81%EC%86%8D/",
    "categories": "Java, Java_Basic",
    "tags": "Java",
    "date": "2024-04-05 00:00:00 +0900",
    





    
    "snippet": "Java 문법 (10) - 상속상속 관계상속은 객체 지향 프로그래밍의 핵심 요소 중 하나로, 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용하게 해줍니다. 이름 그대로 기존 클래스의 속성과 기능을 그대로 물려받는 것이고, exdends 키워드를 사용하며 대상은 하나만 선택 가능합니다.전기차와 가솔린차는 자동차의 더 구체적인 개념이고, 반대로 자...",
    "content": "Java 문법 (10) - 상속상속 관계상속은 객체 지향 프로그래밍의 핵심 요소 중 하나로, 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용하게 해줍니다. 이름 그대로 기존 클래스의 속성과 기능을 그대로 물려받는 것이고, exdends 키워드를 사용하며 대상은 하나만 선택 가능합니다.전기차와 가솔린차는 자동차의 더 구체적인 개념이고, 반대로 자동차는 둘을 포함하는 추상적인 개념입니다. 또한, 자동차의 이동, 문을 열기, 시동걸기 등 공통 기능이 있기 때문에 이런 경우 상속관계를 사용하는 것이 효과적입니다.// Car.javapackage extends1.ex2;    public class Car {      public void move(){          System.out.println(\"차를 이동합니다.\");      }  }// ElectricCar.javapackage extends1.ex2;    public class ElectricCar extends Car {      public void charge(){          System.out.println(\"충전합니다.\");      }  }// GasCar.javapackage extends1.ex2;    public class GasCar extends Car{      public void fillUp(){          System.out.println(\"기름을 주유합니다.\");      }  }// CarMain.javapackage extends1.ex2;  public class CarMain {      public static void main(String[] args) {          ElectricCar electricCar = new ElectricCar();          electricCar.move(); // 상속을 받았기 때문에 Car의 move 함수를 사용 가능          electricCar.charge();            GasCar gasCar = new GasCar();          gasCar.move(); // 상속을 받았기 때문에 Car의 move 함수를 사용 가능          gasCar.fillUp();      }  }new ElectricCar()를 호출하면 ElectricCar 뿐만 아니라 상속관계에 있는 Car까지 포함해서 인스턴스를 생성합니다. 참조값은 하나이지만 그 안에 Car, ElectricCar 두가지 클래스 정보가 공존합니다. 메모리에서는 부모와 자식이 모두 생성되고 공간도 구분됩니다. 메서드를 호출할 대는 호출하는 변수의 타입을 기준으로 선택하는데, 타입이 ElectricCar라면 먼저 ElectricCar 내부에서 찾고 없으면 부모인 Car로 올라가서 찾아서 호출합니다.오버라이딩부모에게서 상속받은 기능을 자식이 재정의 하는 것을 메서드 오버라이딩이라고 합니다. 위의 기존 예시에서 ElectricCar의 move를 메서드 이름은 같지만 새로운 기능으로 사용하고 싶다면 오버라이딩을 하면 됩니다. 기존 Car의 move는 “차를 이동합니다.” 라는 기능이고, 이를 “전기차를 빠르게 이동합니다.”로 재정의 하는 예제입니다.package extends1.overriding;    public class ElectricCar extends Car {      @Override      public void move() {          System.out.println(\"전기차를 빠르게 이동합니다.\");      }        public void charge(){          System.out.println(\"충전합니다.\");      }  }super 부모 참조부모와 자식의 필드명이 같거나, 메서드가 오버라이딩 되어 있으면, 자식에서 부모의 필드나 메서드를 호출할 수 없습니다. 이때 super 키워드를 사용하면 부모를 참조할 수 있습니다.// Parent.javapackage extends1.access.super1;    public class Parent {      public String value = \"parent\";        public void hello(){          System.out.println(\"Parent.hello\");      }  }// Child.javapackage extends1.access.super1;    public class Child extends Parent{      public String value = \"child\";        @Override      public void hello(){          System.out.println(\"Child.hgello\");      }        public void call(){          System.out.println(\"this value = \" + this.value); // this 생략 가능          System.out.println(\"super value = \" + super.value); // 부모의 value          this.hello();    // this 생략 가능        super.hello();   // 부모의 hello() 호출    }  }super - 생성자자바는 상속관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 합니다. 또한 호출할 때 자식 클래스의 생성자 첫줄에 반드시 super(…)를 호출해야 합니다. (기본생성자는 생략 가능). 첫 줄에 super()가 있기 때문에, 항상 가장 위에 있는 부모의 생성자부터 자식의 생성자 순서로 실행이됩니다.package extends1.access.super2;    public class ClassA {      public ClassA(){          System.out.println(\"ClassA 생성자\");      }  }package extends1.access.super2;    public class ClassB extends ClassA {      public ClassB(int a){          super(); // 기본 생성자 생략 가능          System.out.println(\"ClassB 생성자 a = \" + a);      }        public ClassB(int a, int b){          super(); // 기본 생성자 생략 가능          System.out.println(\"ClassB 생성자 a = \" + a + \" b = \" + b);      }  }package extends1.access.super2;    public class ClassC extends ClassB {      public ClassC(){          super(10, 20);          System.out.println(\"ClassC 생성자\");      }  }package extends1.access.super2;    public class SuperMain2 {      public static void main(String[] args) {          ClassC c = new ClassC();      }  }"
  },
  
  {
    "title": "Java 문법 (9) - Final",
    "url": "/posts/Java-%EB%AC%B8%EB%B2%95-(9)-Final/",
    "categories": "Java, Java_Basic",
    "tags": "Java",
    "date": "2024-04-04 00:00:00 +0900",
    





    
    "snippet": "Java 문법 (9) - FinalFinal 변수final이 붙은 변수는 최초에 값을 할당할 때를 제외하고 값을 변경할 수 없습니다. 매개변수에 final이 붙으면 메서드 내부에서 매개변수의 값을 변경할 수 없습니다.package final1;public class FinalLocalMain {\tpublic static void main(String[...",
    "content": "Java 문법 (9) - FinalFinal 변수final이 붙은 변수는 최초에 값을 할당할 때를 제외하고 값을 변경할 수 없습니다. 매개변수에 final이 붙으면 메서드 내부에서 매개변수의 값을 변경할 수 없습니다.package final1;public class FinalLocalMain {\tpublic static void main(String[] args) { //final 지역 변수1\t\tfinal int data1;  \t\tdata1 = 10; //최초 한번만 할당 가능 \t\t//data1 = 20; // 컴파일 오류 변경 불가능\t\t\t//final 지역 변수2  \t\tfinal int data2 = 10; //data2 = 20; //컴파일 오류         method(10);     }     static void method(final int parameter) {\t\t//parameter = 20; 컴파일 오류 변경 불가능\t} }클래스의 필드에서 사용할 때는 생성자를 통해서 초기화 해주고, 그 이후에는 변경할 수 없도록 코드를 작성할 수 있습니다.예시의 final int value2 = 10; 처럼 초기화 해줄 수 있지만, 모든 객체가 10이라는 값을 고정적으로 갖게 됩니다. 이렇게 하면 메모리 낭비가 될 수 있고, 의미가 없기 때문에 이처럼 사용하지는 않고 상수를 사용합니다. package final1;//final 필드 - 생성자 초기화 public class ConstructInit {\tfinal int value;\tfinal int value2 = 10; // 모든 객체가 10으로 고정, 의미가 없음.\t    public ConstructInit(int value) {         this.value = value;\t} }상수상수는 변하지 않고 항상 일정한 값을 갖는 수를 말합니다. 자바에서 보통 단 하나만 존재하는 변하지 않는 고정된 값을 상수라고 합니다. 상수는 static final 키워드를 사용합니다. 관례로 변수의 이름은 대문자를 사용하고 _ (언더 스코어로) 구분합니다. ex) MAX_NUMBER보통 상수는 애플리케이션 전반에서 사용되기 때문에 public을 주로 사용합니다. 상수는 중앙에서 값을 하나로 관리할 수 있습니다. 런타임 중에는 상수를 변경할 수 없습니다.package final1;//상수  public class Constant {\t//수학 상수  \tpublic static final double PI = 3.14;  \t//시간 상수  \tpublic static final int HOURS_IN_DAY = 24; \tpublic static final int MINUTES_IN_HOUR = 60; \tpublic static final int SECONDS_IN_MINUTE = 60; \t//애플리케이션 설정 상수  \tpublic static final int MAX_USERS = 1000;}"
  },
  
  {
    "title": "Java 문법 (8) - 자바 메모리 구조와 static",
    "url": "/posts/Java-%EB%AC%B8%EB%B2%95-(8)-%EC%9E%90%EB%B0%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0%EC%99%80-static/",
    "categories": "Java, Java_Basic",
    "tags": "Java",
    "date": "2024-04-03 00:00:00 +0900",
    





    
    "snippet": "Java 문법 (8) - 자바 메모리 구조와 static자바 메모리 구조자바의 메모리 구조는 크게 메서드 영역, 스택 영역, 힙 영역 3개로 나눌 수 있습니다.메서드 영역메서드 영역은 프로그램을 실행하는데 필요한 공통 데이터를 관리하는 영역입니다. 프로그램의 모든 영역에서 공유합니다.  클래스 정보(클래스의 실행코드, 필드, 매서드, 생성자 등)를 보...",
    "content": "Java 문법 (8) - 자바 메모리 구조와 static자바 메모리 구조자바의 메모리 구조는 크게 메서드 영역, 스택 영역, 힙 영역 3개로 나눌 수 있습니다.메서드 영역메서드 영역은 프로그램을 실행하는데 필요한 공통 데이터를 관리하는 영역입니다. 프로그램의 모든 영역에서 공유합니다.  클래스 정보(클래스의 실행코드, 필드, 매서드, 생성자 등)를 보관  static 변수들을 보관  런타임 상수 풀: 공통 리터럴 상수들을 보관 (ex “hello”)스택 영역스택 영역은 자바 실행시 쓰레드 별로 하나씩 스택이 생성됩니다. 각 스택 프레임은 지역변수, 중간 연산 결과, 메서드 호출 정보 등을 포함합니다.  매서드를 호출할 때마다 하나의 스택 프레임이 쌓이고, 메서드가 종료되면 해당 스택 프레임이 제거  자바는 스택 영역을 사용해서 메서드 호출과 지역변수, 매개변수를 관리  메서드를 계속 호출하면 스택 프레임이 계속 쌓임  스택 프레임이 종료되면 지역변수도 함게 제거, 스택 프레임이 모두 종료되면 프로그램도 종료힙 영역객체(인스턴스)와 배열이 생성되는 영역입니다. GC(가비지 컬렉션)이 이루어지는 주요 영역이고, 더 이상 참조되지 않는 객체는 GC에 의해서 제거됩니다.스택 영역 예시main에서 method1을 호출하고, method1에서 method2를 호출한 예시입니다. 각각 함수마다 start와 end를 시작과 끝에 넣어주면 스택이 어떻게 실행되는지 눈으로 확인할 수 있습니다.main 시작 -&gt; method1 시작 -&gt; method2 시작 -&gt; method2 종료 -&gt; method1 종료 -&gt; main 종료 순으로 실행됩니다.package memory;    public class JavaMemoryMain1 {      public static void main(String[] args) {          System.out.println(\"main start\");          method1(10);          System.out.println(\"main end\");      }      static void method1(int m1){          System.out.println(\"method1 start\");          int cal = m1 * 2;          method2(cal);          System.out.println(\"method1 end\");      }      static void method2(int m2){          System.out.println(\"method2 start\");          System.out.println(\"method2 end\");      }  }// 실행결과// main start// method1 start// method2 start// method2 end// method1 end// main end스택 영역과 힙 영역아래 예시코드는 스택과 힙 영역이 함께 사용되는 경우를 보기 위한 코드입니다.method1에서 Data의 객체 data1이 생성되고, 이 객체의 참조값을 method2의 매개변수로 전달합니다. 실행 순서를 보면 아래와 같습니다.  main()스택 프레임 생성, (main start 출력)  method1() 스택 프레임 생성, (method1 start 출력)  Data의 객체 힙 영역에 생성, data1 이라는 참조값을 담는 지역변수 스택 프레임에 보관  method2() 스택 프레임 생성, data1을 매개변수 data2로 받음, (method2 start 출력)  method2 종료, method2() 스택 프레임 및 data2 제거, (method2 end 출력)  method1 종료, method1() 스텍 프레임 및 data1 제거, (method1 end 출력)  Data의 객체를 참조하는 곳이 없음, GC가 제거  main 종료, main() 스택 프레임 제거, (main end 출력)  프로그램 종료// memory.javapackage memory;    public class Data {      private int value;        public Data(int value) {          this.value = value;      }        public int getValue(){          return value;      }  }// JavaMemoryMain2.javapackage memory;    public class JavaMemoryMain2 {      public static void main(String[] args) {          System.out.println(\"main start\");          method1();          System.out.println(\"main end\");      }      static void method1(){          System.out.println(\"method1 start\");          Data data1 = new Data(10);          method2(data1);          System.out.println(\"method1 end\");      }      static void method2(Data data2){          System.out.println(\"method2 start\");          System.out.println(\"data.value = \" + data2.getValue());          System.out.println(\"method2 end\");      }  }/* 실행결과\tmain start\tmethod1 start\tmethod2 start\tdata.value = 10\tmethod2 end\tmethod1 end\tmain end*/Static 변수static은 주로 멤버변수와 메서드에 사용됩니다.클래스의 멤버변수는 두가지 종류로 나뉩니다.  인스턴스 변수 : static이 붙지 않은 멤버변수 ex) private String name;          인스턴스 변수는 인스턴스를 생성해야 사용할 수 있고, 인스턴스에 소속되어 있어서 인스턴스 변수      인스턴스를 만들 때 마다 새로 만들어짐        클래스 변수 : static이 붙은 멤버 변수 ex) public static int count;          클래스 변수, 정적 변수, static 변수 등으로 불림      static 변수는 클래스 자체에 소속되어 있어서 클래스명으로 바로 접근이 가능하며, 메모리의 메서드 영역에 만들어잠      자바 프로그램을 시작할 때 딱 1개가 만들어지며 보통 여러곳에서 공유하는 목적으로 사용됩니다.      // Data3.javapackage static1;    public class Data3 {      public String name;      public static int count;        public Data3 (String name){          this.name = name;          count++;      }  }// DataCountMain3.javapackage static1;    public class DataCountMain3 {      public static void main(String[] args) {          // static으로 count를 공유하기 때문에 공용으로 사용 가능한 특별하게 관리되는 변수          // static 변수는 메서드 영역에서 관리함          Data3 data1 = new Data3(\"A\");          System.out.println(\"A Count: \" + Data3.count); // static 변수는 클래스명으로 접근 가능하다.          Data3 data2 = new Data3(\"B\");          System.out.println(\"B Count: \" + Data3.count);          Data3 data3 = new Data3(\"C\");          System.out.println(\"C Count: \" + Data3.count);            // 추가 인스턴스를 통한 접근도 가능          // 권장하지 않음. count가 인스턴스변수인지 static 변수인지 코드만 보고 알 수 없다.          Data3 data4 = new Data3(\"D\");          System.out.println(data4.count);            // 클래스를 통한 접근          System.out.println(Data3.count);      }  }Static 메서드매서드 앞에 static이 붙는 것을 정적 메서드 또는 클래스 메서드라고 합니다. 클래스 자체에 소속되어 있어서 객체 생성없이 클래스명으로 메서드를 바로 호출할 수 있습니다.static 메서드는 같은 static만 호출할 수 있습니다. 정적 변수나 정적 메서드만 호출이 가능합니다. 인스턴스 변수나 인스턴스 메서드는 사용할 수 없습니다. 반대로 인스턴스 변수나 메서드는 static 메서드를 호출할 수 있습니다.package static2;    public class DecoData {      private int instanceValue;      private static int staticValue;        // static은 static만 접근 가능      public static void staticCall(){          staticValue++; // 정적 변수 접근          staticMethod(); // 정적 메서드 접근 가능          // instanceValue++; // static method는 인스턴스 변수 접근 불가능          // instanceMethod(); // 인스턴스 메서드 접근 불가능      }        // instance는 static, instance 전부 접근 가능      public void instanceCall(){          instanceValue++; // 인스턴스 변수 접근 가능          instanceMethod(); // 인스턴스 메서드 접근 가능            staticValue++; // 스태틱 변수 접근 가능          staticMethod(); // 스태틱 메서드 접근 가능      }        private void instanceMethod(){          System.out.println(\"instanceValue= \" + instanceValue);      }      private static void staticMethod(){          System.out.println(\"static methpd= \" + staticValue);      }  }"
  },
  
  {
    "title": "Java 문법 (7) - 접근 제어자",
    "url": "/posts/Java-%EB%AC%B8%EB%B2%95-(7)-%EC%A0%91%EA%B7%BC-%EC%A0%9C%EC%96%B4%EC%9E%90/",
    "categories": "Java, Java_Basic",
    "tags": "Java",
    "date": "2024-04-02 00:00:00 +0900",
    





    
    "snippet": "Java 문법 (7) - 접근 제어자접근 제어자자바는 public , private 같은 접근 제어자(access modifier)를 제공합니다. 접근 제어자를 사용하면 해당 클래스 외부에서 특정 필드나 메서드에 접근하는 것을 허용하거나 제한할 수 있습니다.접근 제어자 종류  private: 모든 외부 호출을 막음  default(package-pri...",
    "content": "Java 문법 (7) - 접근 제어자접근 제어자자바는 public , private 같은 접근 제어자(access modifier)를 제공합니다. 접근 제어자를 사용하면 해당 클래스 외부에서 특정 필드나 메서드에 접근하는 것을 허용하거나 제한할 수 있습니다.접근 제어자 종류  private: 모든 외부 호출을 막음  default(package-private): 같은 패키지 안에서 호출만 허용  protected: 같은 패키지 안에서의 호출과, 상속관계의 호출은 허용  public: 모든 외부의 호출을 허용접근 제어자 예시 - 필드, 메서드// access.a 패키지의 AccessData 클래스package access.a;    public class AccessData {      public int publicField;      int defaultField;      private int privateField;        public void publicMethod(){          System.out.println(\"publicMethod 호출 \" + publicField);      }        void defaultMethod(){          System.out.println(\"defaultMethod 호출 \" + defaultField);      }        private void privateMethod(){          System.out.println(\"privateMethod 호출 \" + privateField);      }        public void innerMethod() {          System.out.println(\"내부 호출\");          publicField = 100;          defaultField = 200;          privateField = 300;          publicMethod();          defaultMethod();          privateMethod();      }  }access.a라는 패키지 안에 AccessData라는 클래스를 만들어서 각각 public, default, private 필드와 메서드를 선언했습니다.// access.a 패키지의 AccessinnerMain 클래스package access.a;    public class AccessinnerMain {      public static void main(String[] args) {          AccessData data = new AccessData();            // public 호출 가능          data.publicField = 1;          data.publicMethod();            // default 같은 패키지여서 호출 가능          data.defaultField = 2;          data.defaultMethod();            // private 호출 불가능          //data.privateField = 3;          //data.privateMethod();                  // 내부를 건드리는 함수          data.innerMethod();      }  }같은 패키지인 access.a 안에서 AccessinnerMain 클래스를 만들고, AccessData 객체를 생성해서 사용하는 테스트를 했습니다. public은 호출 가능하고, default도 같은 패키지에 있기 때문에 호출이 가능했으며, private는 접근 불가능합니다.// access.b 패키지의 AccessOuterMain 클래스package access.b;    import access.a.AccessData;    public class AccessOuterMain {      public static void main(String[] args) {          AccessData data = new AccessData();            // public 호출 가능          data.publicField = 1;          data.publicMethod();            // default 다른 패키지여서 호출 불가능          //data.defaultField = 2;          //data.defaultMethod();          // private 호출 불가능          //data.privateField = 3;          //data.privateMethod();          // 내부를 건드리는 함수          data.innerMethod();      }  }이번엔 다른 패키지인 access.b 패키지에서 AccessOuterMain 클래스를 만들어서 AccessData 객체를 생성했습니다. public은 호출이 가능하지만, 패키지가 다르기 때문에 default는 호출 불가능했고, private 또한 호출이 불가능합니다.접근 제어자 - 클래스 레벨클래스 레벨의 접근 제어자는 public, default만 사용할 수 있습니다. 또한 public 클래스는 반드시 파일명과 이름이 같아야하고, 하나의 자바 파일에 하나의 public 클래스만 존재할 수 있습니다.package access.a;    // public 클래스는 파일명과 이름이 같아야 한다.  // 클래스 레벨의 접근 제어자는 public, default만 있다.  public class PublicClass {      int test;      public static void main(String[] args) {          PublicClass publicClass = new PublicClass();          // 같은 파일 접근 가능          DefaultClass1 class1 = new DefaultClass1();          DefaultClass2 class2 = new DefaultClass2();            publicClass.test = 1;      }  }    class DefaultClass1{}  class DefaultClass2{}예시처럼 public 클래스는 파일에 하나만 존재합니다. public으로 선언한 PublicClass는 파일명과 이름이 같아야합니다. 나머지 DefaultClass1, DefaultClass2 는 현재 패키지에서만 사용 가능한 default 클래스입니다.캡슐화캡슐화는 객체지향 프로그래밍의 중요한 개념 중 하나입니다. 캡슐화는 데이터와 해당 데이터를 처리하는 매서드를 하나로 묶어서 외부에서의 접근을 제한하는 방법을 말합니다. 캡슐화를 통해서 데이터의 직접적인 변경을 방지하거나 제한할 수 있습니다. 쉽게 이야기해서 속성과 기능을 하나로 묶고, 외부에는 꼭 필요한 기능만 노출하고 나머지는 모두 내부로 숨기는 것입니다.객체에는 속성(데이터)과 기능(매서드)가 있습니다. 속성은 필수로 숨겨야합니다. 자동차의 속도를 사용자가 직접 변경하는게 아닌 것 처럼 속도(데이터)는 숨겨두고 엑셀을 밟는다는 기능을 통해 속도를 변경할 수 있게 해야합니다.객체의 기능중에도 외부에서는 사용하지 않고 내부에서만 사용되는 기능들이 있습니다. 이러한 기능들도 private로 숨기는 것이 좋습니다.// 캡슐화 예제package access;  // 캡슐화 예제  public class BankAccount {      private int balance;  // 속성 private로 숨기기       public BankAccount() {          balance = 0;      }  \t// 입금 기능 (public 외부에 노출)    public void deposit(int amount){          if (isAmountValid(amount)){              balance += amount;          }else {              System.out.println(\"유효하지 않은 금액입니다.\");          }      }  \t// 출금 기능(public 외부 노출)    public void withdraw(int amount){          if(isAmountValid(amount) &amp;&amp; balance - amount &gt;= 0){              balance -= amount;          } else {              System.out.println(\"유효하지 않은 금액이거나, 잔액이 부족합니다.\");          }        }  \t// 잔액 확인 기능(public 외부 노툴)    public void showBalance(){          System.out.println(\"현재 잔액: \" + balance);      }          // 들어온 금액이 올바른지 판단 (private 내부에서만 사용하는 코드 숨김)    private boolean isAmountValid(int amount){          return amount &gt; 0;      }  }캡슐화 예제 코드입니다. balance 속성은 private로 내부에 숨겼습니다. deposit, withdraw, showBalance는 입금, 출금, 잔액확인 등 사용자가 써야할 꼭 필요한 기능으로 public을 사용해 외부에서 접근할 수 있게 합니다. isAmountValid는 입력으로 들어온 금액이 유효한지 판단하는 기능으로, 내부에서만 사용되기 때문에 private로 숨겨줍니다."
  },
  
  {
    "title": "Programmers Java Lv.0 (21) - 외계행성의 나이",
    "url": "/posts/Programmers-Java-Lv.0-(21)-%EC%99%B8%EA%B3%84%ED%96%89%EC%84%B1%EC%9D%98-%EB%82%98%EC%9D%B4/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-04-01 00:00:00 +0900",
    





    
    "snippet": "외계행성의 나이문제 설명우주여행을 하던 머쓱이는 엔진 고장으로 PROGRAMMERS-962 행성에 불시착하게 됐습니다. 입국심사에서 나이를 말해야 하는데, PROGRAMMERS-962 행성에서는 나이를 알파벳으로 말하고 있습니다. a는 0, b는 1, c는 2, …, j는 9입니다. 예를 들어 23살은 cd, 51살은 fb로 표현합니다. 나이 age가...",
    "content": "외계행성의 나이문제 설명우주여행을 하던 머쓱이는 엔진 고장으로 PROGRAMMERS-962 행성에 불시착하게 됐습니다. 입국심사에서 나이를 말해야 하는데, PROGRAMMERS-962 행성에서는 나이를 알파벳으로 말하고 있습니다. a는 0, b는 1, c는 2, …, j는 9입니다. 예를 들어 23살은 cd, 51살은 fb로 표현합니다. 나이 age가 매개변수로 주어질 때 PROGRAMMER-962식 나이를 return하도록 solution 함수를 완성해주세요.제한사항  age는 자연수입니다.  age ≤ 1,000  PROGRAMMERS-962 행성은 알파벳 소문자만 사용합니다.입출력 예****            age      result                  23      “cd”              51      “fb”              100      “baa”      입출력 예 설명입출력 예 #1  age가 23이므로 “cd”를 return합니다.입출력 예 #2  age가 51이므로 “fb”를 return합니다.입출력 예 #3  age가 100이므로 “baa”를 return합니다.Solution  a~j(0~9)까지 str 배열에 담아두고, age의 각 자릿수의 숫자를 뽑아서 str의 index로 사용해서 문제를 풀었습니다.import java.util.*;class Solution {    public String solution(int age) {        String[] str = {\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\"};        String ageStr = Integer.toString(age);        String answer = \"\";        for(int i = 0; i&lt;ageStr.length(); i++){            answer = answer + str[Integer.valueOf(ageStr.charAt(i)+\"\")];        }                return answer;    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (20) - 배열 자르기",
    "url": "/posts/Programmers-Java-Lv.0-(20)-%EB%B0%B0%EC%97%B4-%EC%9E%90%EB%A5%B4%EA%B8%B0/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-04-01 00:00:00 +0900",
    





    
    "snippet": "배열 자르기문제 설명정수 배열 numbers와 정수 num1, num2가 매개변수로 주어질 때, numbers의 num1번 째 인덱스부터 num2번째 인덱스까지 자른 정수 배열을 return 하도록 solution 함수를 완성해보세요.제한사항  2 ≤ numbers의 길이 ≤ 30  0 ≤ numbers의 원소 ≤ 1,000  0 ≤num1 &lt; ...",
    "content": "배열 자르기문제 설명정수 배열 numbers와 정수 num1, num2가 매개변수로 주어질 때, numbers의 num1번 째 인덱스부터 num2번째 인덱스까지 자른 정수 배열을 return 하도록 solution 함수를 완성해보세요.제한사항  2 ≤ numbers의 길이 ≤ 30  0 ≤ numbers의 원소 ≤ 1,000  0 ≤num1 &lt; num2 &lt; numbers의 길이입출력 예            numbers      num1      num2      result                  [1, 2, 3, 4, 5]      1      3      [2, 3, 4]              [1, 3, 5]      1      2      [3, 5]      입출력 예 설명입출력 예 #1  [1, 2, 3, 4, 5]의 1번째 인덱스 2부터 3번째 인덱스 4 까지 자른 [2, 3, 4]를 return 합니다.입출력 예 #2  [1, 3, 5]의 1번째 인덱스 3부터 2번째 인덱스 5까지 자른 [3, 5]를 return 합니다.Solution  num2 - num1 + 1로 배열의 크기를 정하고, 반복문을 num1…num2 까지 돌면서 새로 선언한 배열에 값을 하나씩 넣어주는 방식으로 문제를 풀었습니다.class Solution {    public int[] solution(int[] numbers, int num1, int num2) {        int[] answer = new int[num2-num1+1];                for (int i = num1; i&lt;=num2; i++){            answer[i-num1] = numbers[i];        }        return answer;    }}  Arrays.copyOfRange(기존 배열, 시작 인덱스, 끝 인덱스라는 함수를 이용하면 코드를 간략하게 구현할 수 있습니다.import java.util.*;class Solution {    public int[] solution(int[] numbers, int num1, int num2) {        return Arrays.copyOfRange(numbers, num1, num2 + 1);    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (19) - 짝수의 합",
    "url": "/posts/Programmers-Java-Lv.0-(19)-%EC%A7%9D%EC%88%98%EC%9D%98-%ED%95%A9/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-04-01 00:00:00 +0900",
    





    
    "snippet": "짝수의 합문제 설명정수 n이 주어질 때, n이하의 짝수를 모두 더한 값을 return 하도록 solution 함수를 작성해주세요.제한사항0 &lt; n ≤ 1000입출력 예            n      result                  10      30              4      6      입출력 예 설명입출력 예 #1  n이...",
    "content": "짝수의 합문제 설명정수 n이 주어질 때, n이하의 짝수를 모두 더한 값을 return 하도록 solution 함수를 작성해주세요.제한사항0 &lt; n ≤ 1000입출력 예            n      result                  10      30              4      6      입출력 예 설명입출력 예 #1  n이 10이므로 2 + 4 + 6 + 8 + 10 = 30을 return 합니다.입출력 예 #2  n이 4이므로 2 + 4 = 6을 return 합니다.Solution  반복문의 i 를 2씩 더해서 짝수를 모두 더했습니다.class Solution {    public int solution(int n) {        int answer = 0;        for(int i = 0; i &lt;= n; i+=2){            answer += i;        }        return answer;    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (18) - 양꼬치",
    "url": "/posts/Programmers-Java-Lv.0-(18)-%EC%96%91%EA%BC%AC%EC%B9%98/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-04-01 00:00:00 +0900",
    





    
    "snippet": "양꼬치문제 설명머쓱이네 양꼬치 가게는 10인분을 먹으면 음료수 하나를 서비스로 줍니다. 양꼬치는 1인분에 12,000원, 음료수는 2,000원입니다. 정수 n과 k가 매개변수로 주어졌을 때, 양꼬치 n인분과 음료수 k개를 먹었다면 총얼마를 지불해야 하는지 return 하도록 solution 함수를 완성해보세요.제한사항  0 &lt; n &lt; 1,0...",
    "content": "양꼬치문제 설명머쓱이네 양꼬치 가게는 10인분을 먹으면 음료수 하나를 서비스로 줍니다. 양꼬치는 1인분에 12,000원, 음료수는 2,000원입니다. 정수 n과 k가 매개변수로 주어졌을 때, 양꼬치 n인분과 음료수 k개를 먹었다면 총얼마를 지불해야 하는지 return 하도록 solution 함수를 완성해보세요.제한사항  0 &lt; n &lt; 1,000  n / 10 ≤ k &lt; 1,000  서비스로 받은 음료수는 모두 마십니다.입출력 예            n      k      result                  10      3      124,000              64      6      768,000      입출력 예 설명입출력 예 #1  10인분을 시켜 서비스로 음료수를 하나 받아 총 10 * 12000 + 3 * 2000 - 1 * 2000 = 124,000원입니다.입출력 예 #2  64인분을 시켜 서비스로 음료수를 6개 받아 총 64 * 12000 + 6 * 2000 - 6 * 2000 =768,000원입니다.Solution  10인분을 먹었지만 음료수를 안받는 경우를 생각해서 문제를 풀었었지만, n / 10 ≤ k &lt; 1,000 조건이 있어서 고려하지 않아도 괜찮습니다. n을 10으로 나눈 몫을 k에서 빼주면 서비스 음료를 제외하고 먹은 음료의 개수를 알 수 있습니다. 이를 통해 n인분 양꼬치 값 + 음료 값으로 문제를 풀었습니다.class Solution {    public int solution(int n, int k) {        int drinkCount = k - (n / 10);        return 12000 * n + (drinkCount &gt; 0 ? drinkCount * 2000 : 0);    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (17) - 각도기",
    "url": "/posts/Programmers-Java-Lv.0-(17)-%EA%B0%81%EB%8F%84%EA%B8%B0/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-04-01 00:00:00 +0900",
    





    
    "snippet": "각도기문제 설명각에서 0도 초과 90도 미만은 예각, 90도는 직각, 90도 초과 180도 미만은 둔각 180도는 평각으로 분류합니다. 각 angle이 매개변수로 주어질 때 예각일 때 1, 직각일 때 2, 둔각일 때 3, 평각일 때 4를 return하도록 solution 함수를 완성해주세요.  예각 : 0 &lt; angle &lt; 90  직각 : ...",
    "content": "각도기문제 설명각에서 0도 초과 90도 미만은 예각, 90도는 직각, 90도 초과 180도 미만은 둔각 180도는 평각으로 분류합니다. 각 angle이 매개변수로 주어질 때 예각일 때 1, 직각일 때 2, 둔각일 때 3, 평각일 때 4를 return하도록 solution 함수를 완성해주세요.  예각 : 0 &lt; angle &lt; 90  직각 : angle = 90  둔각 : 90 &lt; angle &lt; 180  평각 : angle = 180제한사항  0 &lt; angle ≤ 180  angle은 정수입니다.입출력 예            angle      result                  70      1              91      3              180      4      입출력 예 설명입출력 예 #1  angle이 70이므로 예각입니다. 따라서 1을 return합니다.입출력 예 #2  angle이 91이므로 둔각입니다. 따라서 3을 return합니다.입출력 예 #2  angle이 180이므로 평각입니다. 따라서 4를 return합니다.Solution  if 문을 사용해서 문제를 풀었습니다.class Solution {    public int solution(int angle) {        if (angle &lt; 90) {            return 1;        }        else if (angle == 90) {            return 2;        }        else if (angle &lt; 180) {            return 3;        }        else {            return 4;        }    }}"
  },
  
  {
    "title": "Java 문법 (6) - 생성자",
    "url": "/posts/Java-%EB%AC%B8%EB%B2%95-(6)-%EC%83%9D%EC%84%B1%EC%9E%90/",
    "categories": "Java, Java_Basic",
    "tags": "Java",
    "date": "2024-04-01 00:00:00 +0900",
    





    
    "snippet": "Java 문법 (6) - 생성자생성자의 선언과 호출  생성자의 이름은 클래스의 이름과 같아야합니다. (대소문자까지)  생성자는 반환타입이 없습니다.  생성자의 매개변수의 이름과 클래스 요소들의 이름이 같다면, this를 붙여주어야 합니다.public class Book {      String title;      String author;      ...",
    "content": "Java 문법 (6) - 생성자생성자의 선언과 호출  생성자의 이름은 클래스의 이름과 같아야합니다. (대소문자까지)  생성자는 반환타입이 없습니다.  생성자의 매개변수의 이름과 클래스 요소들의 이름이 같다면, this를 붙여주어야 합니다.public class Book {      String title;      String author;      int page;        // 생성자 코드    Book(String title, String author, int page) {  \t    this.title = title;  \t    this.author = author;  \t    this.page = page;  \t}\t}public class BookMain {      public static void main(String[] args) {  \t\tBook book1 = new Book(\"JPA 프로그래밍\", \"kim\", 700);    }}생성자의 특징  생성자는 객체를 생성하는 시점에서 어떤 작업을 하고 싶을 때 유용합니다.  선언하고 초기화매서드를 또 호출하는 등의 중복 호출을 제거할 수 있는 효과가 있습니다.  매개변수가 있는 생성자는 반드시 호출해야 하기 때문에 제약을 주어서 오류를 방지할 수 있습니다."
  },
  
  {
    "title": "Programmers Java Lv.0 (16) - 특정 문자 제거하기",
    "url": "/posts/Programmers-Java-Lv.0-(16)-%ED%8A%B9%EC%A0%95-%EB%AC%B8%EC%9E%90-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-30 00:00:00 +0900",
    





    
    "snippet": "특정 문자 제거하기문제 설명문자열 my_string과 문자 letter이 매개변수로 주어집니다. my_string에서 letter를 제거한 문자열을 return하도록 solution 함수를 완성해주세요.제한사항  1 ≤ my_string의 길이 ≤ 100  letter은 길이가 1인 영문자입니다.  my_string과 letter은 알파벳 대소문자로 ...",
    "content": "특정 문자 제거하기문제 설명문자열 my_string과 문자 letter이 매개변수로 주어집니다. my_string에서 letter를 제거한 문자열을 return하도록 solution 함수를 완성해주세요.제한사항  1 ≤ my_string의 길이 ≤ 100  letter은 길이가 1인 영문자입니다.  my_string과 letter은 알파벳 대소문자로 이루어져 있습니다.  대문자와 소문자를 구분합니다.입출력 예            my_string      letter      result                  “abcdef”      “f”      “abcde”              “BCBdbe”      “B”      “Cdbe”      입출력 예 설명입출력 예 #1  “abcdef” 에서 “f”를 제거한 “abcde”를 return합니다.입출력 예 #2  “BCBdbe” 에서 “B”를 모두 제거한 “Cdbe”를 return합니다.Solution  반복문을 사용해서 my_string의 요소가 letter와 같으면 넘어가고, 아니면 answer에 더하는 방식으로 문제를 풀었습니다.class Solution {    public String solution(String my_string, String letter) {        String answer = \"\";        for(int i = 0; i &lt; my_string.length(); i++){            if (letter.equals(my_string.charAt(i)+\"\")){                continue;            }            answer += (my_string.charAt(i) + \"\");        }                return answer;    }}  String에 replace라는 함수를 이용하면 코드를 더 간결하게 만들 수 있습니다.class Solution {    public String solution(String my_string, String letter) {        return my_string.replace(letter, \"\");    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (15) - 문자 반복 출력하기",
    "url": "/posts/Programmers-Java-Lv.0-(15)-%EB%AC%B8%EC%9E%90-%EB%B0%98%EB%B3%B5-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-30 00:00:00 +0900",
    





    
    "snippet": "문자 반복 출력하기문제 설명문자열 my_string과 정수 n이 매개변수로 주어질 때, my_string에 들어있는 각 문자를 n만큼 반복한 문자열을 return 하도록 solution 함수를 완성해보세요.제한사항  2 ≤ my_string 길이 ≤ 5  2 ≤ n ≤ 10  “my_string”은 영어 대소문자로 이루어져 있습니다.입출력 예     ...",
    "content": "문자 반복 출력하기문제 설명문자열 my_string과 정수 n이 매개변수로 주어질 때, my_string에 들어있는 각 문자를 n만큼 반복한 문자열을 return 하도록 solution 함수를 완성해보세요.제한사항  2 ≤ my_string 길이 ≤ 5  2 ≤ n ≤ 10  “my_string”은 영어 대소문자로 이루어져 있습니다.입출력 예            my_string      n      result                  “hello”      3      “hhheeellllllooo”      입출력 예 설명입출력 예 #1  “hello”의 각 문자를 세 번씩 반복한 “hhheeellllllooo”를 return 합니다.Solution  StringBuffer, 이중 반복문을 이용해 문자를 append하는 방법으로 문제를 풀었습니다.class Solution {    public String solution(String my_string, int n) {        StringBuffer answer = new StringBuffer();                for (int i = 0; i &lt; my_string.length(); i++){            for (int j = 0; j&lt;n; j++){                answer.append(my_string.charAt(i));                }        }                return answer.toString();    }}  이전 문제에서 배운 StringBuilder, repeat를 사용해서 문제를 다시 풀어봤습니다. charAt()은 char 타입으로 반환되기 때문에 + \"\"를 해줌으로써 String으로 타입 캐스팅 할 수 있었습니다.class Solution {    public String solution(String my_string, int n) {        StringBuilder stringBuilder = new StringBuilder();        for (int i = 0; i &lt; my_string.length(); i++){            String temp = my_string.charAt(i) + \"\";            stringBuilder.append(temp.repeat(n));        }        return stringBuilder.toString();    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (14) - 짝수 홀수 개수",
    "url": "/posts/Programmers-Java-Lv.0-(14)-%EC%A7%9D%EC%88%98-%ED%99%80%EC%88%98-%EA%B0%9C%EC%88%98/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-30 00:00:00 +0900",
    





    
    "snippet": "짝수 홀수 개수문제 설명정수가 담긴 리스트 num_list가 주어질 때, num_list의 원소 중 짝수와 홀수의 개수를 담은 배열을 return 하도록 solution 함수를 완성해보세요.제한사항  1 ≤ num_list의 길이 ≤ 100  0 ≤ num_list의 원소 ≤ 1,000입출력 예            num_list      result...",
    "content": "짝수 홀수 개수문제 설명정수가 담긴 리스트 num_list가 주어질 때, num_list의 원소 중 짝수와 홀수의 개수를 담은 배열을 return 하도록 solution 함수를 완성해보세요.제한사항  1 ≤ num_list의 길이 ≤ 100  0 ≤ num_list의 원소 ≤ 1,000입출력 예            num_list      result                  [1, 2, 3, 4, 5]      [2, 3]              [1, 3, 5, 7]      [0, 4]      입출력 예 설명입출력 예 #1  [1, 2, 3, 4, 5]에는 짝수가 2, 4로 두 개, 홀수가 1, 3, 5로 세 개 있습니다.입출력 예 #2  [1, 3, 5, 7]에는 짝수가 없고 홀수가 네 개 있습니다.Solution  반복문으로 num_list의 요소들을 확인하면서 짝수라면 answer[0]의 값을 증가하고 홀수면 answer[1]의 값을 증가시켜서 문제를 풀었습니다.class Solution {    public int[] solution(int[] num_list) {        int[] answer = {0,0};        for(int num: num_list){            if (num % 2 == 0){                answer[0]++;            }            else {                answer[1]++;            }        }        return answer;    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (13) - 직각삼각형 출력하기",
    "url": "/posts/Programmers-Java-Lv.0-(13)-%EC%A7%81%EA%B0%81%EC%82%BC%EA%B0%81%ED%98%95-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-30 00:00:00 +0900",
    





    
    "snippet": "직각삼각형 출력하기문제 설명““의 높이와 너비를 1이라고 했을 때, ““을 이용해 직각 이등변 삼각형을 그리려고합니다. 정수 n 이 주어지면 높이와 너비가 n 인 직각 이등변 삼각형을 출력하도록 코드를 작성해보세요.제한사항  1 ≤ n ≤ 10입출력 예입력 #13출력 #1******입출력 예 설명입출력 예 #1  n이 3이므로 첫째 줄에 * 1개, 둘...",
    "content": "직각삼각형 출력하기문제 설명““의 높이와 너비를 1이라고 했을 때, ““을 이용해 직각 이등변 삼각형을 그리려고합니다. 정수 n 이 주어지면 높이와 너비가 n 인 직각 이등변 삼각형을 출력하도록 코드를 작성해보세요.제한사항  1 ≤ n ≤ 10입출력 예입력 #13출력 #1******입출력 예 설명입출력 예 #1  n이 3이므로 첫째 줄에 * 1개, 둘째 줄에 * 2개, 셋째 줄에 * 3개를 출력합니다.Solution  이중 반복문을 통해서 i는 1~n까지, j는 1~i까지 반복하도록 코드를 작성했습니다.import java.util.Scanner;public class Solution {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();                for (int i = 1 ; i &lt;= n; i++){            for (int j = 1; j&lt;=i; j++){                System.out.print(\"*\");            }            System.out.println();        }            }}  다른 사람의 풀이 방식을 보다가, String에 repeat()함수를 알게되어서 유용하게 사용할 수 있을 것 같습니다.import java.util.Scanner;public class Solution {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();                for (int i = 1 ; i &lt;= n; i++){\t\t\tSystem.out.println(\"*\".repeat(i)); //repeat()        }    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (12) - 문자열 뒤집기",
    "url": "/posts/Programmers-Java-Lv.0-(12)-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%92%A4%EC%A7%91%EA%B8%B0/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-30 00:00:00 +0900",
    





    
    "snippet": "문자열 뒤집기문제 설명문자열 my_string이 매개변수로 주어집니다. my_string을 거꾸로 뒤집은 문자열을 return하도록 solution 함수를 완성해주세요.제한사항  1 ≤ my_string의 길이 ≤ 1,000입출력 예            my_string      return                  “jaron”      “no...",
    "content": "문자열 뒤집기문제 설명문자열 my_string이 매개변수로 주어집니다. my_string을 거꾸로 뒤집은 문자열을 return하도록 solution 함수를 완성해주세요.제한사항  1 ≤ my_string의 길이 ≤ 1,000입출력 예            my_string      return                  “jaron”      “noraj”              “bread”      “daerb”      입출력 예 설명입출력 예 #1  my_string이 “jaron”이므로 거꾸로 뒤집은 “noraj”를 return합니다.입출력 예 #2  my_string이 “bread”이므로 거꾸로 뒤집은 “daerb”를 return합니다.Solution  캐릭터 배열을 my_string.length()의 크기로 만들어 주고, my_string의 길이만큼 반복문을 돌면서 캐릭터 배열에 반대로 넣어주고, String으로 변환해 반환하는 방법으로 문제를 풀었습니다.class Solution {    public String solution(String my_string) {        char[] arr = new char[my_string.length()];        for(int i = 0; i &lt; my_string.length(); i++){            arr[i] = my_string.charAt(my_string.length() - i - 1);                    }        return String.valueOf(arr);    }}  Java의 StringBuilder를 사용하면 해당 문제를 간결하게 풀 수 있습니다.class Solution {    public String solution(String my_string) {        StringBuilder stringBuilder = new StringBuilder(my_string);        return stringBuilder.reverse().toString();    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (9) - 아이스 아메리카노",
    "url": "/posts/Programmers-Java-Lv.0-(9)-%EC%95%84%EC%9D%B4%EC%8A%A4-%EC%95%84%EB%A9%94%EB%A6%AC%EC%B9%B4%EB%85%B8/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-29 00:00:00 +0900",
    





    
    "snippet": "아이스 아메리카노문제 설명머쓱이는 추운 날에도 아이스 아메리카노만 마십니다. 아이스 아메리카노는 한잔에 5,500원입니다. 머쓱이가 가지고 있는 돈 money가 매개변수로 주어질 때, 머쓱이가 최대로 마실 수 있는 아메리카노의 잔 수와 남는 돈을 순서대로 담은 배열을 return 하도록 solution 함수를 완성해보세요.제한사항  0 &lt; mon...",
    "content": "아이스 아메리카노문제 설명머쓱이는 추운 날에도 아이스 아메리카노만 마십니다. 아이스 아메리카노는 한잔에 5,500원입니다. 머쓱이가 가지고 있는 돈 money가 매개변수로 주어질 때, 머쓱이가 최대로 마실 수 있는 아메리카노의 잔 수와 남는 돈을 순서대로 담은 배열을 return 하도록 solution 함수를 완성해보세요.제한사항  0 &lt; money ≤ 1,000,000입출력 예            money      result                  5,500      [1, 0]              15,000      [2, 4000]      입출력 예 설명입출력 예 #1  5,500원은 아이스 아메리카노 한 잔을 살 수 있고 잔돈은 0원입니다.입출력 예 #2  15,000원은 아이스 아메리카노 두 잔을 살 수 있고 잔돈은 4,000원입니다.Solution  잔 수는 돈(money)을 아메리카노의 가격(5500)으로 나눈 몫이고, 잔돈은 나머지가 됩니다.class Solution {    public int[] solution(int money) {        int[] answer = {money / 5500, money % 5500};        return answer;    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (8) - 옷가게 할인 받기",
    "url": "/posts/Programmers-Java-Lv.0-(8)-%EC%98%B7%EA%B0%80%EA%B2%8C-%ED%95%A0%EC%9D%B8-%EB%B0%9B%EA%B8%B0/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-29 00:00:00 +0900",
    





    
    "snippet": "옷가게 할인 받기문제 설명머쓱이네 옷가게는 10만 원 이상 사면 5%, 30만 원 이상 사면 10%, 50만 원 이상 사면 20%를 할인해줍니다.구매한 옷의 가격 price가 주어질 때, 지불해야 할 금액을 return 하도록 solution 함수를 완성해보세요.제한사항  10 ≤ price ≤ 1,000,000          price는 10원 단...",
    "content": "옷가게 할인 받기문제 설명머쓱이네 옷가게는 10만 원 이상 사면 5%, 30만 원 이상 사면 10%, 50만 원 이상 사면 20%를 할인해줍니다.구매한 옷의 가격 price가 주어질 때, 지불해야 할 금액을 return 하도록 solution 함수를 완성해보세요.제한사항  10 ≤ price ≤ 1,000,000          price는 10원 단위로(1의 자리가 0) 주어집니다.        소수점 이하를 버린 정수를 return합니다.입출력 예            price      result                  150,000      142,500              580,000      464,000      입출력 예 설명입출력 예 #1  150,000원에서 5%를 할인한 142,500원을 return 합니다.입출력 예 #2  580,000원에서 20%를 할인한 464,000원을 return 합니다.Solution  단순하게 if문을 사용해서 50만원 부터 차례로 검사하는 코드로 문제를 풀었습니다.class Solution {    public int solution(int price) {        double answer = 0;        if (price &gt;= 500000) {            answer = price - (price * 0.2);        } else if (price &gt;= 300000) {            answer = price - (price * 0.1);        } else if (price &gt;= 100000) {            answer = price - (price * 0.05);        } else {            return price;        }                        return (int)answer;    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (11) - 배열 뒤집기",
    "url": "/posts/Programmers-Java-Lv.0-(11)-%EB%B0%B0%EC%97%B4-%EB%92%A4%EC%A7%91%EA%B8%B0/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-29 00:00:00 +0900",
    





    
    "snippet": "배열 뒤집기문제 설명정수가 들어 있는 배열 num_list가 매개변수로 주어집니다. num_list의 원소의 순서를 거꾸로 뒤집은 배열을 return하도록 solution 함수를 완성해주세요.제한사항  1 ≤ num_list의 길이 ≤ 1,000  0 ≤ num_list의 원소 ≤ 1,000입출력 예            num_list      res...",
    "content": "배열 뒤집기문제 설명정수가 들어 있는 배열 num_list가 매개변수로 주어집니다. num_list의 원소의 순서를 거꾸로 뒤집은 배열을 return하도록 solution 함수를 완성해주세요.제한사항  1 ≤ num_list의 길이 ≤ 1,000  0 ≤ num_list의 원소 ≤ 1,000입출력 예            num_list      result                  [1, 2, 3, 4, 5]      [5, 4, 3, 2, 1]              [1, 1, 1, 1, 1, 2]      [2, 1, 1, 1, 1, 1]              [1, 0, 1, 1, 1, 3, 5]      [5, 3, 1, 1, 1, 0, 1]      입출력 예 설명입출력 예 #1  num_list가 [1, 2, 3, 4, 5]이므로 순서를 거꾸로 뒤집은 배열 [5, 4, 3, 2, 1]을 return합니다.입출력 예 #2  num_list가 [1, 1, 1, 1, 1, 2]이므로 순서를 거꾸로 뒤집은 배열 [2, 1, 1, 1, 1, 1]을 return합니다.입출력 예 #3  num_list가 [1, 0, 1, 1, 1, 3, 5]이므로 순서를 거꾸로 뒤집은 배열 [5, 3, 1, 1, 1, 0, 1]을 return합니다.Solution  주어진 배열의 길이를 구하고, 그 길이만큼 새로운 배열을 만들었습니다. 반복문을 돌면서 기존 배열은 뒤에서부터 값을 새로운 배열의 앞부터 넣어주었습니다.class Solution {    public int[] solution(int[] num_list) {        int length = num_list.length;        int[] answer = new int[length];        for(int i = 0; i &lt; length; i++){            answer[i] = num_list[length-i-1];        }                return answer;    }}  Java에 Stream 라이브러리를 사용하는게 중요한데, LongStream을 사용해서 문제를 푼 답안을 찾게되었습니다.import java.util.stream.LongStream;class Solution {    public int[] solution(int[] num_list) {        return LongStream.range(1, num_list.length + 1)                .mapToInt(i -&gt; num_list[(int) (num_list.length - i)])                .toArray();    }}  해당 답안을 참고하여 IntStream을 이용해서 문제를 다시 풀어보았습니다.import java.util.stream.IntStream;class Solution {    public int[] solution(int[] num_list) {        int length = num_list.length;        return IntStream.range(1, length + 1)            .map(i -&gt; num_list[length - i])            .toArray();    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (10) - 나이 출력",
    "url": "/posts/Programmers-Java-Lv.0-(10)-%EB%82%98%EC%9D%B4-%EC%B6%9C%EB%A0%A5/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-29 00:00:00 +0900",
    





    
    "snippet": "나이 출력문제 설명머쓱이는 선생님이 몇 년도에 태어났는지 궁금해졌습니다. 2022년 기준 선생님의 나이 age가 주어질 때, 선생님의 출생 연도를 return 하는 solution 함수를 완성해주세요제한사항  0 &lt; age ≤ 120  나이는 태어난 연도에 1살이며 매년 1월 1일마다 1살씩 증가합니다.입출력 예            age    ...",
    "content": "나이 출력문제 설명머쓱이는 선생님이 몇 년도에 태어났는지 궁금해졌습니다. 2022년 기준 선생님의 나이 age가 주어질 때, 선생님의 출생 연도를 return 하는 solution 함수를 완성해주세요제한사항  0 &lt; age ≤ 120  나이는 태어난 연도에 1살이며 매년 1월 1일마다 1살씩 증가합니다.입출력 예            age      result                  40      1983              23      2000      입출력 예 설명입출력 예 #1  2022년 기준 40살이므로 1983년생입니다.입출력 예 #2  2022년 기준 23살이므로 2000년생입니다.Solution  나이는 2022년 기준이라고 정해져 있기 때문에, 2022 - age + 1로 구할 수 있습니다.class Solution {    public int solution(int age) {        int answer = 2022 - age + 1;                return answer;    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (7) - 배열의 평균값",
    "url": "/posts/Programmers-Java-Lv.0-(7)-%EB%B0%B0%EC%97%B4%EC%9D%98-%ED%8F%89%EA%B7%A0%EA%B0%92/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-28 00:00:00 +0900",
    





    
    "snippet": "배열의 평균값문제 설명정수 배열 numbers가 매개변수로 주어집니다. numbers의 원소의 평균값을 return하도록 solution 함수를 완성해주세요.제한사항  0 ≤ numbers의 원소 ≤ 1,000  1 ≤ numbers의 길이 ≤ 100  정답의 소수 부분이 .0 또는 .5인 경우만 입력으로 주어집니다.입출력 예            nu...",
    "content": "배열의 평균값문제 설명정수 배열 numbers가 매개변수로 주어집니다. numbers의 원소의 평균값을 return하도록 solution 함수를 완성해주세요.제한사항  0 ≤ numbers의 원소 ≤ 1,000  1 ≤ numbers의 길이 ≤ 100  정답의 소수 부분이 .0 또는 .5인 경우만 입력으로 주어집니다.입출력 예            numbers      result                  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]      5.5              [89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]      94.0      입출력 예 설명입출력 예 #1  numbers의 원소들의 평균 값은 5.5입니다.입출력 예 #2  numbers의 원소들의 평균 값은 94.0입니다.Solution  배열의 모든 요소를 더해서 배열의 길이로 나누어서 평균을 구했습니다.class Solution {    public double solution(int[] numbers) {\t    int sum = 0;\t    \t\tfor(int number: numbers){\t\t\tsum += number;        }                return (double) sum / numbers.length;    }}  다른 풀이들을 보니 Java의 Stream을 사용해서 더 간결한 코드를 작성할 수도 있었습니다.import java.util.*;class Solution {    public double solution(int[] numbers) {        return Arrays.stream(numbers).average().orElse(0);\t}}"
  },
  
  {
    "title": "Programmers Java Lv.0 (6) - 피자 나눠먹기 3",
    "url": "/posts/Programmers-Java-Lv.0-(6)-%ED%94%BC%EC%9E%90-%EB%82%98%EB%88%A0%EB%A8%B9%EA%B8%B0-3/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-28 00:00:00 +0900",
    





    
    "snippet": "피자 나눠먹기 3문제 설명머쓱이네 피자가게는 피자를 두 조각에서 열 조각까지 원하는 조각 수로 잘라줍니다. 피자 조각 수 slice와 피자를 먹는 사람의 수 n이 매개변수로 주어질 때, n명의 사람이 최소 한 조각 이상 피자를 먹으려면 최소 몇 판의 피자를 시켜야 하는지를 return 하도록 solution 함수를 완성해보세요.제한사항  2 ≤ sli...",
    "content": "피자 나눠먹기 3문제 설명머쓱이네 피자가게는 피자를 두 조각에서 열 조각까지 원하는 조각 수로 잘라줍니다. 피자 조각 수 slice와 피자를 먹는 사람의 수 n이 매개변수로 주어질 때, n명의 사람이 최소 한 조각 이상 피자를 먹으려면 최소 몇 판의 피자를 시켜야 하는지를 return 하도록 solution 함수를 완성해보세요.제한사항  2 ≤ slice ≤ 10  1 ≤ n ≤ 100입출력 예            slice      n      result                  7      10      2              4      12      3      입출력 예 설명입출력 예 #1  10명이 7조각으로 자른 피자를 한 조각 이상씩 먹으려면 최소 2판을 시켜야 합니다.입출력 예 #2  12명이 4조각으로 자른 피자를 한 조각 이상씩 먹으려면 최소 3판을 시켜야 합니다.Solution  피자 나눠먹기 1 과 마찬가지로 인원수(n)를 조각(slice)으로 나눈 나머지가 0일 때에는 몫을 반환, 아닐 때에는 몫 + 1을 반환하는 방법으로 문제를 풀었습니다.class Solution {    public int solution(int slice, int n) {        int answer = n % slice == 0 ? n / slice : (n/slice) + 1;        return answer;    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (5) - 피자 나눠먹기 2",
    "url": "/posts/Programmers-Java-Lv.0-(5)-%ED%94%BC%EC%9E%90-%EB%82%98%EB%88%A0%EB%A8%B9%EA%B8%B0-2/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-28 00:00:00 +0900",
    





    
    "snippet": "피자 나눠먹기 2문제 설명머쓱이네 피자가게는 피자를 여섯 조각으로 잘라 줍니다. 피자를 나눠먹을 사람의 수 n이 매개변수로 주어질 때, n명이 주문한 피자를 남기지 않고 모두 같은 수의 피자 조각을 먹어야 한다면 최소 몇 판을 시켜야 하는지를 return 하도록 solution 함수를 완성해보세요.제한사항1 ≤ n ≤ 100입출력 예          ...",
    "content": "피자 나눠먹기 2문제 설명머쓱이네 피자가게는 피자를 여섯 조각으로 잘라 줍니다. 피자를 나눠먹을 사람의 수 n이 매개변수로 주어질 때, n명이 주문한 피자를 남기지 않고 모두 같은 수의 피자 조각을 먹어야 한다면 최소 몇 판을 시켜야 하는지를 return 하도록 solution 함수를 완성해보세요.제한사항1 ≤ n ≤ 100입출력 예            n      result                  6      1              10      5              4      2      입출력 예 설명입출력 예 #1  6명이 모두 같은 양을 먹기 위해 한 판을 시켜야 피자가 6조각으로 모두 한 조각씩 먹을 수 있습니다.입출력 예 #2  10명이 모두 같은 양을 먹기 위해 최소 5판을 시켜야 피자가 30조각으로 모두 세 조각씩 먹을 수 있습니다.입출력 예 #3  4명이 모두 같은 양을 먹기 위해 최소 2판을 시키면 피자가 12조각으로 모두 세 조각씩 먹을 수 있습니다.Solution  반복문을 통해 i를 1씩 증가시켜 나가고, i * 6(조각 수)를 n으로 나눈 나머지가 0이 되었을 때의 i를 return 함으로써 최소 공배수를 구했습니다.class Solution {    public int solution(int n) {         int i = 1;                while (true){            if ((6*i) % n == 0) {                return i;            }            i++;        }    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (4) - 피자 나눠먹기 1",
    "url": "/posts/Programmers-Java-Lv.0-(4)-%ED%94%BC%EC%9E%90-%EB%82%98%EB%88%A0%EB%A8%B9%EA%B8%B0-1/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-28 00:00:00 +0900",
    





    
    "snippet": "피자 나눠먹기 1문제 설명머쓱이네 피자가게는 피자를 일곱 조각으로 잘라 줍니다. 피자를 나눠먹을 사람의 수 n이 주어질 때, 모든 사람이 피자를 한 조각 이상 먹기 위해 필요한 피자의 수를 return 하는 solution 함수를 완성해보세요.제한사항  1 ≤ n ≤ 100입출력 예            n      result              ...",
    "content": "피자 나눠먹기 1문제 설명머쓱이네 피자가게는 피자를 일곱 조각으로 잘라 줍니다. 피자를 나눠먹을 사람의 수 n이 주어질 때, 모든 사람이 피자를 한 조각 이상 먹기 위해 필요한 피자의 수를 return 하는 solution 함수를 완성해보세요.제한사항  1 ≤ n ≤ 100입출력 예            n      result                  7      1              1      1              15      3      입출력 예 설명입출력 예 #1  7명이 최소 한 조각씩 먹기 위해서 최소 1판이 필요합니다.입출력 예 #2  1명은 최소 한 조각을 먹기 위해 1판이 필요합니다.입출력 예 #3  15명이 최소 한 조각씩 먹기 위해서 최소 3판이 필요합니다.Solution  인원수 n이 7조각으로 딱 나눠 떨어질 때에는 n/7, 아닐 때에는 n/7 +1 로 풀었습니다.class Solution {    public int solution(int n) {        int answer = n % 7 == 0 ? n/7 : (n/7) + 1;        return answer;    }}"
  },
  
  {
    "title": "Java 문법 (5) - 객체 지향 프로그래밍",
    "url": "/posts/Java-%EB%AC%B8%EB%B2%95-(5)-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/",
    "categories": "Java, Java_Basic",
    "tags": "Java",
    "date": "2024-03-27 00:00:00 +0900",
    





    
    "snippet": "Java 문법 (5) - 객체 지향 프로그래밍\b절차 지향과 객체 지향절차지향  이름 그대로 절차를 지향하는 프로그래밍입니다. 실행 순서를 중요하게 생각하는 방식입니다.  프로그램의 흐름을 순차적으로 따르며 처리하는 방식입니다.  “어떻게”를 중심으로 프로그래밍 합니다.  데이터와 데이터에 대한 처리방식이 분리되어 있습니다.객체지향  객체를 중요하게 생...",
    "content": "Java 문법 (5) - 객체 지향 프로그래밍\b절차 지향과 객체 지향절차지향  이름 그대로 절차를 지향하는 프로그래밍입니다. 실행 순서를 중요하게 생각하는 방식입니다.  프로그램의 흐름을 순차적으로 따르며 처리하는 방식입니다.  “어떻게”를 중심으로 프로그래밍 합니다.  데이터와 데이터에 대한 처리방식이 분리되어 있습니다.객체지향  객체를 중요하게 생각하는 방식입니다.  실제 세계의 사물이나 사건을 객체로 보고, 이러한 객체들 간의 상호작용을 중심으로 프로그래밍하는 방식입니다.  “무엇을” 중심으로 프로그래밍 합니다.  데이터와 데이터에 대한 행동(메서드)가 하나의 객체 안에 포함되어 있습니다.절차지향 프로그래밍 예시  예시와 같이 데이터와 기능이 분리되어 있는 것을 볼 수 있습니다. 예시의 메서드 대부분 MusicPlayer의 데이터를 사용합니다. 만약 이후에 관련 데이터가 변경되면 메서드들도 함께 변경해야하고, 데이터와 기능이 분리되어 있기 때문에 유지보수 관점에서도 관리해야할 부분이 2곳으로 늘어나게 됩니다.// 음악 플레이어 클래스// 데이터public class MusicPlayer {      int volume;      boolean isOn;}public class MusicPlayerMain2 {      public static void main(String[] args) {          MusicPlayerData data = new MusicPlayerData();            on(data);          volumeUp(data);          volumeUp(data);          volumeDown(data);          showStatus(data);          off(data);        }    // 데이터 처리 메서드     static void on(MusicPlayerData data) {          data.isOn = true;          System.out.println(\"음악 플레이어를 시작합니다.\");      }        static void off(MusicPlayerData data) {          data.isOn = false;          System.out.println(\"음악 플레이어를 종료합니다.\");      }        static void volumeUp(MusicPlayerData data){          data.volume++;          System.out.println(\"음악 플레이어 볼륨: \" + data.volume);      }        static void volumeDown(MusicPlayerData data){          data.volume--;          System.out.println(\"음악 플레이어 볼륨: \" + data.volume);      }        static void showStatus(MusicPlayerData data){          if (data.isOn){              System.out.println(\"음악 플레이어 ON\" + \", 볼륨: \" + data.volume);          } else {              System.out.println(\"음악 플레이어 Off\");          }      }  }객체지향 프로그래밍 예시  예시와 같이 MusicPlayer안에 데이터와 기능이 모두 같이 들어있습니다. 음악 플레이어를 구성하기 위한 속성과 기능이 하나의 캡슐에 쌓여있는 것 같고, 필요한 기능을 매서드를 통해서 외부에 제공합니다. 이를 캡슐화라고 합니다.객체지향 프로그래밍을 하게 되면 사람의 입장에서 더 읽기 쉬운 코드가 만들어지고, 유지보수에도 더 좋습니다.// MusicPlayer의 데이터과 기능public class MusicPlayer {      int volume;      boolean isOn;        void on(){          isOn = true;          System.out.println(\"음악 플레이어를 시작합니다.\");      }        void off(){          isOn = false;          System.out.println(\"음악 플레이어를 종료합니다.\");      }      void volumeUp(){          volume++;          System.out.println(\"음악 플레이어 볼륨: \" + volume);      }      void volumeDown(){          volume--;          System.out.println(\"음악 플레이어 볼륨: \" + volume);      }      void showStatus(){          if (isOn){              System.out.println(\"음악 플레이어 ON\" + \", 볼륨: \" + volume);          } else {              System.out.println(\"음악 플레이어 Off\");          }      }  }public class MusicPlayerMain3 {      public static void main(String[] args) {          MusicPlayer musicPlayer = new MusicPlayer();          musicPlayer.on();          musicPlayer.volumeUp();          musicPlayer.volumeUp();          musicPlayer.volumeDown();          musicPlayer.showStatus();          musicPlayer.off();      }  }"
  },
  
  {
    "title": "Programmers Java Lv.0 (3) - 짝수는 싫어요",
    "url": "/posts/Programmers-Java-Lv.0-(3)-%EC%A7%9D%EC%88%98%EB%8A%94-%EC%8B%AB%EC%96%B4%EC%9A%94/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-26 00:00:00 +0900",
    





    
    "snippet": "짝수는 싫어요문제 설명정수 n이 매개변수로 주어질 때, n 이하의 홀수가 오름차순으로 담긴 배열을 return하도록 solution 함수를 완성해주세요.제한사항  1 ≤ n ≤ 100입출력 예            n      result                  10      [1, 3, 5, 7, 9]              15      [1...",
    "content": "짝수는 싫어요문제 설명정수 n이 매개변수로 주어질 때, n 이하의 홀수가 오름차순으로 담긴 배열을 return하도록 solution 함수를 완성해주세요.제한사항  1 ≤ n ≤ 100입출력 예            n      result                  10      [1, 3, 5, 7, 9]              15      [1, 3, 5, 7, 9, 11, 13, 15]      입출력 예 설명입출력 #1  10 이하의 홀수가 담긴 배열 [1, 3, 5, 7, 9]를 return합니다.입출력 #1  15 이하의 홀수가 담긴 배열 [1, 3, 5, 7, 9, 11, 13, 15]를 return합니다.Solution  ArrayList를 사용했으며, for문으로 i를 1부터 2씩 증가시키며 array에 add했습니다. 이후 ArrayList를 array로 변환하여 출력했습니다.import java.util.*;class Solution {    public int[] solution(int n) {        ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;();                for (int i = 1; i &lt;= n; i+=2){            array.add(i);        }                return array.stream().mapToInt(x-&gt;x).toArray();    }}"
  },
  
  {
    "title": "Programmers Java Lv.0 (2) - 최빈값 구하기",
    "url": "/posts/Programmers-Java-Lv.0-(2)-%EC%B5%9C%EB%B9%88%EA%B0%92-%EA%B5%AC%ED%95%98%EA%B8%B0/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-26 00:00:00 +0900",
    





    
    "snippet": "최빈값 구하기문제 설명최빈값은 주어진 값 중에서 가장 자주 나오는 값을 의미합니다. 정수 배열 array가 매개변수로 주어질 때, 최빈값을 return 하도록 solution 함수를 완성해보세요. 최빈값이 여러 개면 -1을 return 합니다.제한사항  0 &lt; array의 길이 &lt; 100  0 ≤ array의 원소 &lt; 1000입출력 예...",
    "content": "최빈값 구하기문제 설명최빈값은 주어진 값 중에서 가장 자주 나오는 값을 의미합니다. 정수 배열 array가 매개변수로 주어질 때, 최빈값을 return 하도록 solution 함수를 완성해보세요. 최빈값이 여러 개면 -1을 return 합니다.제한사항  0 &lt; array의 길이 &lt; 100  0 ≤ array의 원소 &lt; 1000입출력 예            array      result                  [1, 2, 3, 3, 3, 4]      3              [1, 1, 2, 2]      -1              [1]      1      입출력 예 설명입출력 예 #1  [1, 2, 3, 3, 3, 4]에서 1은 1개 2는 1개 3은 3개 4는 1개로 최빈값은 3입니다.입출력 예 #2  [1, 1, 2, 2]에서 1은 2개 2는 2개로 최빈값이 1, 2입니다. 최빈값이 여러 개이므로 -1을 return 합니다.입출력 예 #3  [1]에는 1만 있으므로 최빈값은 1입니다.Solution  HashMap을 사용해서 배열을 돌면서 각 숫자별 나온 횟수를 저장하고, 그 값이 현재까지 나온 값중 가장 높은 값일 경우에 max와, 해당 숫자를 업데이트 해줍니다. 이후 answer를 반환합니다.import java.util.*;class Solution {    public int solution(int[] array) {       Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        int max = 0;        int answer = 0;        for (int i = 0; i &lt; array.length; i++) {            Integer temp = map.getOrDefault(array[i], 0) + 1;            map.put(array[i], temp);            if (max &lt; temp) {                max = temp;                answer = array[i];            } else if (max == temp) {                answer = -1;            }        }        return answer;    }}"
  },
  
  {
    "title": "Java 문법 (4) - 기본형과 참조형",
    "url": "/posts/Java-%EB%AC%B8%EB%B2%95-(4)-%EA%B8%B0%EB%B3%B8%ED%98%95%EA%B3%BC-%EC%B0%B8%EC%A1%B0%ED%98%95/",
    "categories": "Java, Java_Basic",
    "tags": "Java",
    "date": "2024-03-26 00:00:00 +0900",
    





    
    "snippet": "Java 문법 (4) - 기본형과 참조형기본형 vs 참조형대원칙: 자바는 항상 변수의 값을 복사해서 대입한다.기본형  int, long, double, boolean 처럼 변수에 사용할 값을 직접 넣을 수 있는 데이터 타입  10, 20과 같이 실제 사용하는 값을 변수에 담을 수 있다  들어 있는 값을 그대로 계산에 사용할 수 있다참조형  Studen...",
    "content": "Java 문법 (4) - 기본형과 참조형기본형 vs 참조형대원칙: 자바는 항상 변수의 값을 복사해서 대입한다.기본형  int, long, double, boolean 처럼 변수에 사용할 값을 직접 넣을 수 있는 데이터 타입  10, 20과 같이 실제 사용하는 값을 변수에 담을 수 있다  들어 있는 값을 그대로 계산에 사용할 수 있다참조형  Student student1, int[] students 처럼 데이터에 접근하기 위한 참조(메모리 주소)값을 저장하는 데이터 타입  실제 사용하는 값을 담는게 아닌, 실제 객체의 참조(주소)를 저장한다.  참조값을 그대로 사용할 수 없다기본형의 변수 대입자바에서 변수에 값을 대입하는 것은 변수에 들어 있는 값을 복사해서 대입하는 것입니다. 따라서 기본형은 변수에 10, 20 과 같은 실제 사용할 수 있는 값들이 담겨있어서 그 값을 복사해서 대입합니다.public class VarChange1 {      public static void main(String[] args) {          int a = 10;          int b = a;          System.out.println(\"a = \" + a);  // a = 10        System.out.println(\"b = \" + b);  // b = 10        a = 20;          System.out.println(\"a = \" + a);  // a = 20        System.out.println(\"b = \" + b);  // b = 10        b = 30;          System.out.println(\"a = \" + a);  // a = 20        System.out.println(\"b = \" + b);  // b = 30    }  }따라서 메모리 공간에 a에 10, b에 10 따로 저장했기에 a를 바꾸어도 b는 바뀌지 않고, b를 바꿔도 a가 바뀌지는 않습니다.참조형의 변수 대입참조형도 똑같이 변수에 들어있는 값을 복사해서 대입합니다. 참조형 변수에는 객체의 참조값(주소)이 들어있기 때문에 해당 참조값을 복사해서 대입합니다.    public static void main(String[] args) {          Data dataA = new Data();          dataA.value = 10;          Data dataB = dataA;            System.out.println(\"dataA 참조값 = \" + dataA);  // dataA 참조값 = ref.Data@30f39991                System.out.println(\"dataB 참조값 = \" + dataB);  // dataB 참조값 = ref.Data@30f39991          System.out.println(\"dataA.value = \" + dataA.value); // dataA.value = 10          System.out.println(\"dataB.value = \" + dataB.value); // dataB.value = 10            dataA.value = 20;          System.out.println(\"dataA.value = \" + dataA.value); // dataA.value = 20          System.out.println(\"dataB.value = \" + dataB.value); // dataB.value = 20            dataB.value = 30;          System.out.println(\"dataA.value = \" + dataA.value); // dataA.value = 30          System.out.println(\"dataB.value = \" + dataB.value); // dataB.value = 30      }  }그러므로 메모리에 Data 객체 하나가 존재하고, 이 객체를 찾아갈 수 있는 주소값을 가진 변수가 dataA, dataB 두개가 됩니다. 객체 자체는 하나이기 때문에 dataA.value를 변경해도 dataB.value가 변경됩니다.기본형과 참조형의 메서드 호출\b메서드 호출도 같은 원리가 적용됩니다. 메서드를 호출할 때 사용하는 매개변수에 값을 전달할 때에도 현재 변수에 들어있는 값을 복사해서 전달합니다. 매개변수로 전달된 x는 a에 들어있는 값을 복사해서 전달한 것으로, 10이라는 기본형 값이 들어있기 때문에 메모리에 서로 다른 공간을 갖고있습니다. 따라서 메서드가 실행된 이후에도 a의 값은 변하지 않습니다.// 기본형 메서드 호출public class MethodChange1 {      public static void main(String[] args) {          int a = 10;          System.out.println(\"a = \" + a); // a = 10        changePrimitive(a);          System.out.println(\"a = \" + a);  // a = 10    }      public static void changePrimitive(int x){          x = 20;      }  }참조형은 dataA의 객체의 주소를 x에 전달하기 때문에, x.value를 변경했을 때, dataA.value 가 변경된 값을 가지고 있는 것을 확인할 수 있습니다.// 참조형 메서드 호출    public static void main(String[] args) {          Data dataA = new Data();          dataA.value = 10;          System.out.println(\"dataA = \" + dataA.value);          changePrimitive(dataA);          System.out.println(\"dataA = \" + dataA.value);      }      public static void changePrimitive(Data x){          x.value = 20;      }  }"
  },
  
  {
    "title": "Programmers Java Lv.0 (1) - 중앙값 구하기",
    "url": "/posts/Programmers-Java-Lv.0-(1)-%EC%A4%91%EC%95%99%EA%B0%92-%EA%B5%AC%ED%95%98%EA%B8%B0/",
    "categories": "Programmers, Lv.0_Java",
    "tags": "Java, Java문법",
    "date": "2024-03-25 00:00:00 +0900",
    





    
    "snippet": "중앙값 구하기문제 설명중앙값은 어떤 주어진 값들을 크기의 순서대로 정렬했을 때 가장 중앙에 위치하는 값을 의미합니다. 예를 들어 1, 2, 7, 10, 11의 중앙값은 7입니다. 정수 배열 array가 매개변수로 주어질 때, 중앙값을 return 하도록 solution 함수를 완성해보세요.제한사항  array의 길이는 홀수입니다.  0 &lt; arr...",
    "content": "중앙값 구하기문제 설명중앙값은 어떤 주어진 값들을 크기의 순서대로 정렬했을 때 가장 중앙에 위치하는 값을 의미합니다. 예를 들어 1, 2, 7, 10, 11의 중앙값은 7입니다. 정수 배열 array가 매개변수로 주어질 때, 중앙값을 return 하도록 solution 함수를 완성해보세요.제한사항  array의 길이는 홀수입니다.  0 &lt; array의 길이 &lt; 100  -1,000 &lt; array의 원소 &lt; 1,000입출력 예            array      result                  [1, 2, 7, 10, 11]      7              [9, -1, 0]      0      입출력 예 설명입출력 예 #1  본문과 동일합니다.입출력 예 #2  9, -1, 0을 오름차순 정렬하면 -1, 0, 9이고 가장 중앙에 위치하는 값은 0입니다.Solution  주어진 배열을 정렬하고, array.length / 2의 몫을 인덱스로하여 배열의 중앙값을 찾았습니다.import java.util.*;class Solution {    public int solution(int[] array) {        Arrays.sort(array);               int answer = array[array.length / 2];                return answer;    }}"
  },
  
  {
    "title": "Java 문법 (3) - 새로운 Switch문",
    "url": "/posts/Java-%EB%AC%B8%EB%B2%95-(3)-%EC%83%88%EB%A1%9C%EC%9A%B4-Switch%EB%AC%B8/",
    "categories": "Java, Java_Start",
    "tags": "Java",
    "date": "2024-03-15 00:00:00 +0900",
    





    
    "snippet": "Java 문법 (2) - 새로운 Switch문기존 Switch자바의 switch 문은 아래와 같이 작성할 수 있습니다. 하지만 break도 꼭 써줘야하고, if 문보다 조금은 더 보기 편하지만 많이 차이나지는 않습니다. 따라서 Java14부터는 새로운 switch문을 사용할 수 있습니다.switch (조건){  \tcase 1 :  \t\t// 조건의 결과...",
    "content": "Java 문법 (2) - 새로운 Switch문기존 Switch자바의 switch 문은 아래와 같이 작성할 수 있습니다. 하지만 break도 꼭 써줘야하고, if 문보다 조금은 더 보기 편하지만 많이 차이나지는 않습니다. 따라서 Java14부터는 새로운 switch문을 사용할 수 있습니다.switch (조건){  \tcase 1 :  \t\t// 조건의 결과값이 1일 때 실행할 코드  \t\tbreak;  \tcase 2:  \t\t// 조건의 결과값이 2일 때 실행할 코드\t\tbreak;  \tcase 3:  \t\t// 조건의 결과값이 3일 때 실행할 코드\t\tbreak;  \tdefault:  \t\t// 조건이 위의 어떤 값에도 해당하지 않을 때 실행할 코드}새로운 Switch기본적으로 아래와 같은 형식으로 switch 문을 작성할 수 있습니다. 훨씬 코드가 간결해진 모습입니다.switch(조건){\tcase 1 -&gt; //조건이 1일 떄 실행할 코드;\tcase 2 -&gt; //조건이 2일 떄 실행할 코드;\tdefault -&gt; // 조건이 위의 어떤 값에도 해당하지 않을 때 실행할 코드 }거기다 추가적으로 switch의 결과값을 return 받아서 변수에 할당해줄 수도 있습니다.int result = switch(조건){\tcase 1 -&gt; 10//조건이 1일 떄 실행할 코드;\tcase 2 -&gt; 20 //조건이 2일 떄 실행할 코드;\tdefault -&gt; -1 // 조건이 위의 어떤 값에도 해당하지 않을 때 실행할 코드 }"
  },
  
  {
    "title": "Java 문법 (2) - 변수",
    "url": "/posts/Java-%EB%AC%B8%EB%B2%95-(2)-%EB%B3%80%EC%88%98/",
    "categories": "Java, Java_Start",
    "tags": "Java",
    "date": "2024-03-14 00:00:00 +0900",
    





    
    "snippet": "Java 문법 (2) - 변수자바의 변수 초기화자바에서 변수를 선언하고 초기화하지 않고 출력하려고 하면 \"java: variable a might not have been initialized\" 라는 오류메시지가 나타납니다. 이 오류메시지는 변수를 초기화하지 않았다는 것을 알려주는데요. 컴퓨터의 메모리는 여러 시스템이 공유하는 자원으로, 다양한 값들이...",
    "content": "Java 문법 (2) - 변수자바의 변수 초기화자바에서 변수를 선언하고 초기화하지 않고 출력하려고 하면 \"java: variable a might not have been initialized\" 라는 오류메시지가 나타납니다. 이 오류메시지는 변수를 초기화하지 않았다는 것을 알려주는데요. 컴퓨터의 메모리는 여러 시스템이 공유하는 자원으로, 다양한 값들이 저장됩니다. 변수를 선언하면 메모리 상에 일정 공간을 차지하게 되는데, 이 공간은 이전에 다른 값이 저장되었던 곳일 수 있습니다. 그 공간에 어떤 값이 있었는지 알 수 없기 때문에 초기화하지 않은 변수의 공간에는 쓰레기값이 남아있습니다. 이러한 쓰레기값으로 인해 예상치 못한 결과가 출력될 수 있으므로, 이를 방지하기 위해 자바는 변수의 초기화를 강제합니다.package variable;    public class Var6 {      public static void main(String[] args) {          int a;          System.out.println(a); // 에러 : \"java: variable a might not have been initialized\"    }  }그렇다면 변수의 초기화를 강제하지 않는 언어에서는 어떻게 될지 궁금해서 C언어에서 Java 예시코드와 같은 코드를 작성하고 실행시켜 봤습니다.#include &lt;stdio.h&gt;int main(){\tint a;\tprintf(\"%d\",a);\treturn 0;}아래 이미지와 같이 예상할 수 없는 값들이 출력되는 것을 확인할 수 있었습니다. 이는 예측 불가능한 결과를 나타낼 수 있기 때문에, 변수를 사용하기 전에 항상 초기화하는 것을 습관화 해야합니다."
  },
  
  {
    "title": "Java 문법 (1) - Java",
    "url": "/posts/Java-%EB%AC%B8%EB%B2%95-(1)-Java/",
    "categories": "Java, Java_Start",
    "tags": "Java",
    "date": "2024-03-14 00:00:00 +0900",
    





    
    "snippet": "Java 문법 (1) - JavaJava 표준 스펙과 구현자바는 표준 스펙(설계도와 문서)과 여러 회사에서 실제로 구현한 다양한 자바 버전으로 나눌 수 있습니다. 이러한 표준 스펙은 자바 커뮤니티 프로세스(JCP)를 통해 관리되며, 다양한 구현은 각각의 OS에서 작동하도록 설계되어 있습니다. 예를 들어, Amazon Corretto는 AWS에 최적화되...",
    "content": "Java 문법 (1) - JavaJava 표준 스펙과 구현자바는 표준 스펙(설계도와 문서)과 여러 회사에서 실제로 구현한 다양한 자바 버전으로 나눌 수 있습니다. 이러한 표준 스펙은 자바 커뮤니티 프로세스(JCP)를 통해 관리되며, 다양한 구현은 각각의 OS에서 작동하도록 설계되어 있습니다. 예를 들어, Amazon Corretto는 AWS에 최적화되어 있습니다. 자바 구현들은 대부분 호환성이 높아, 한 구현에서 다른 구현으로 변경하는 것이 비교적 용이합니다.자바의 특징자바는 Write once, run everywhere라는 모토를 가지고 있습니다. 그래서 나타난 중요한 특징 중 하나가 바로 운영체제 독립성입니다. 자바 프로그램은 다양한 운영체제에서 실행될 수 있으므로, 개발자는 특정 OS에 종속되지 않고 개발할 수 있습니다. 이는 자바가 각 운영체제에 맞는 명령어로 구성되어 있기 때문이며, 개발 환경과 운영 환경이 다를 경우에도 자바의 이러한 특성 덕분에 문제없이 프로그램을 실행할 수 있습니다. 예를 들어, 개발자는 윈도우나 MAC OS에서 개발을 진행하고, 서버에서는 리눅스를 사용하여도 자바 프로그램이 잘 작동합니다.자바의 실행자바 프로그램은 소스 코드(.java)를 컴파일하여 바이트코드(.class)로 변환한 뒤, 자바 가상 머신(JVM)을 통해 실행합니다. 자바 소스 코드를 바이트코드로 변환하며 자바 가상 머신에서 더 빠르게 실행될 수 있게 최적화하고 문법 오류도 검출합니다."
  },
  
  {
    "title": "SQL Grammer (11) - Date",
    "url": "/posts/SQL-Grammer-(11)-Date/",
    "categories": "MySQL, SQL Grammer",
    "tags": "MySQL",
    "date": "2024-03-13 00:00:00 +0900",
    





    
    "snippet": "SQL Grammer (11) - DateDate년, 월, 일, 시, 분, 초 등의 값을 모두 갖고 있으며, 목적에 따라 월, 주, 일 등으로 포맷을 변경할 수 있습니다.데이터에 날짜를 지정하거나, 조건에 날짜를 사용해야할 때 유용합니다.  date_format          년: Y(4자리) , y(2자리)      월: M,m      일: d,...",
    "content": "SQL Grammer (11) - DateDate년, 월, 일, 시, 분, 초 등의 값을 모두 갖고 있으며, 목적에 따라 월, 주, 일 등으로 포맷을 변경할 수 있습니다.데이터에 날짜를 지정하거나, 조건에 날짜를 사용해야할 때 유용합니다.  date_format          년: Y(4자리) , y(2자리)      월: M,m      일: d, e      요일: w      select date(date) date_type,         date_format(date(date), '%Y') \"년\",         date_format(date(date), '%m') \"월\",         date_format(date(date), '%d') \"일\",         date_format(date(date), '%w') \"요일\"  from payments            date_type      년      월      일      요일                  1978-08-23      1978      08      23      3              1974-03-24      1974      03      24      0              2008-05-16      2008      05      16      5              1973-09-27      1973      09      27      4      "
  },
  
  {
    "title": "SQL Grammer (10) - Pivot tabel, Window function",
    "url": "/posts/SQL-Grammer-(10)-Pivot-tabel,-Window-function/",
    "categories": "MySQL, SQL Grammer",
    "tags": "MySQL",
    "date": "2024-03-13 00:00:00 +0900",
    





    
    "snippet": "SQL Grammer (10) - Pivot tabel, Window functionPivot tabel2개 이상의 기준으로 데이터를 집계할 때, 보기 쉽게 배열하여 보여주는 것을 의미합니다. 집계 기준을 행의 기준으로 잡고, 구분 컬럼으로 데이터를 보여줄 수 있습니다.select restaurant_name,         max(if(hh='15'...",
    "content": "SQL Grammer (10) - Pivot tabel, Window functionPivot tabel2개 이상의 기준으로 데이터를 집계할 때, 보기 쉽게 배열하여 보여주는 것을 의미합니다. 집계 기준을 행의 기준으로 잡고, 구분 컬럼으로 데이터를 보여줄 수 있습니다.select restaurant_name,         max(if(hh='15', cnt_order, 0)) \"15\",         max(if(hh='16', cnt_order, 0)) \"16\",         max(if(hh='17', cnt_order, 0)) \"17\",         max(if(hh='18', cnt_order, 0)) \"18\",         max(if(hh='19', cnt_order, 0)) \"19\",         max(if(hh='20', cnt_order, 0)) \"20\"  from  (  select a.restaurant_name,         substring(b.time, 1, 2) hh,         count(1) cnt_order  from food_orders a inner join payments b on a.order_id=b.order_id  where substring(b.time, 1, 2) between 15 and 20  group by 1, 2  ) a  group by 1  order by 7 desc;이렇게 하면 음식점 별, 시간대별 주문 건수를 한눈에 확인할 수 있게 데이터를 조회할 수 있습니다.            restaurant_name      15      16      17      18      19      20                  Shake Shack      13      7      6      9      3      9              The Meatball Shop      4      2      7      3      4      9              Blue Ribbon Fried Chicken      5      4      2      4      4      5      Window function각 행의 관계를 정의하기 위한 함수로, 그룹 내의 연산을 쉽게 만들어주는 함수입니다. 예를 들어 한식 식당 중에서 주문건수가 많은 순으로 순위를 매기고 싶은 경우에 사용할 수 있습니다.기본 구조는 window_function(argument) over (partition by 기준 칼럼, order by 정렬 기준)의 형태로 쓰입니다.select cuisine_type,         restaurant_name,         order_count,         rn \"순위\"  from  (  select cuisine_type,         restaurant_name,         rank() over (partition by cuisine_type order by order_count desc) rn,         order_count  from  (  select cuisine_type, restaurant_name, count(1) order_count  from food_orders  group by 1, 2  ) a  ) b  where rn&lt;=3  order by 1, 4;Rank()를 사용해 음식의 타입별로 레스토랑들의 주문건수 순위를 볼 수 있습니다.            cuisine_type      restaurant_name      order_count      순위                  American      Shake Shack      219      1              American      Blue Ribbon Fried Chicken      96      2              American      Five Guys Burgers and Fries      29      3              Chinese      RedFarm Broadway      59      1              Chinese      RedFarm Hudson      55      2              Chinese      Han Dynasty      46      3      "
  },
  
  {
    "title": "SQL Grammer (9) - Null, Coalesce",
    "url": "/posts/SQL-Grammer-(9)-Null,-Coalesce/",
    "categories": "MySQL, SQL Grammer",
    "tags": "MySQL",
    "date": "2024-03-12 00:00:00 +0900",
    





    
    "snippet": "SQL Grammer (9) - Null, CoalesceNull값이 없을 때 Null 을 이용한다. 숫자 계산같은 함수를 사용할 때 알아두면 좋은 점이 있는데, Null로 처리한 것과 다른 문자로 처리된 경우 계산값이 다르게 나올 수 있다는 것이다.MySQL에서는 사용할 수 없는 값이 연산으로 들어오면 자동으로 0으로 간주한다. Avg로 평균을 구하...",
    "content": "SQL Grammer (9) - Null, CoalesceNull값이 없을 때 Null 을 이용한다. 숫자 계산같은 함수를 사용할 때 알아두면 좋은 점이 있는데, Null로 처리한 것과 다른 문자로 처리된 경우 계산값이 다르게 나올 수 있다는 것이다.MySQL에서는 사용할 수 없는 값이 연산으로 들어오면 자동으로 0으로 간주한다. Avg로 평균을 구하는데 하나의 값이 0으로 들어가면서 자릿수는 차지해버려 평균값을 깎아먹는 역할을 하게된다. 하지만 Null로 되어있다면 완전히 제외되어서 계산에 포함되지 않는다.ex)select restaurant_name,         avg(rating) average_of_rating,         avg(if(rating&lt;&gt;'Not given', rating, null)) average_of_rating2  from food_orders  group by 1;rating이라는 테이블에는 없는 값이 null이 아니라 ‘Not given’이라는 문자로 처리되어 있다. 이 때 2번째줄 처럼 avg를 사용하면 자동으로 ‘Not given’을 0으로 처리하여 연산한다. 하지만 3번째 줄 처럼 ‘Not given’을 null로 변환해서 처리한다면 0으로 간주하지 않고 아예 계산 목록에서 제외시켜 버려서 3번째 값의 숫자가 더 크게 나온다.  원래 데이터            restaurant_name      rating                  Hangawi      Not given              Blue Ribbon Sushi Izakaya      Not given              Cafe Habana      5              Blue Ribbon Fried Chicken      3        출력 결과            restaurant_name      average_of_rating      average_of_rating2                  Blue Ribbon Sushi Izakaya      2.689655172413793      4.333333333333333              Cafe Habana      2.9375      4.2727272727272725              Blue Ribbon Fried Chicken      2.8854166666666665      4.328125      Coalesce\b조회한 값이 null 이고, 이를 대신해 다른 값으로 사용하고 싶을 때 쓸 수 있습니다. coalesce(컬럼, 대체값)의 형태로 사용할 수 있습니다. 아래 예시는 null인 값들만 가져와서, “null 제거” 컬럼에 대체된 20이라는 값을 넣어주는 예시입니다.select b.name,         b.age,         coalesce(b.age, 20) \"null 제거\"  from food_orders a           left join customers b on a.customer_id = b.customer_id  where b.age is null;            name      age      null 제거                  Null      Null      20              Null      Null      20              Null      Null      20              Null      Null      20      "
  },
  
  {
    "title": "SQL Grammer (8) - Join",
    "url": "/posts/SQL-Grammer-(8)-Join/",
    "categories": "MySQL, SQL Grammer",
    "tags": "MySQL",
    "date": "2024-03-12 00:00:00 +0900",
    





    
    "snippet": "SQL Grammer (8) - JoinJoin필요한 데이터가 서로 다른 테이블에 있을 때 사용할 수 있는 문법입니다. 공통 컬럼을 기준으로 두 테이블을 합쳐서 각각 테이블에서 필요한 데이터를 조회할 수 있습니다.Join의 종류  Inner Join          가장 많이 사용하는 조인으로, 두 테이블 모두에 있는 값만 조회하는 것을 말합니다.  ...",
    "content": "SQL Grammer (8) - JoinJoin필요한 데이터가 서로 다른 테이블에 있을 때 사용할 수 있는 문법입니다. 공통 컬럼을 기준으로 두 테이블을 합쳐서 각각 테이블에서 필요한 데이터를 조회할 수 있습니다.Join의 종류  Inner Join          가장 많이 사용하는 조인으로, 두 테이블 모두에 있는 값만 조회하는 것을 말합니다.        OuterJoin          left, right, full 이 있으며 각각 왼쪽 테이블의 모든 값 조회, 오른쪽 테이블의 모든 값 조회, 모든 테이블의 모든 값 조회를 할 수 있습니다.        Cross Join          한쪽 테이블의 모든 행과 다른쪽 테이블의 모든 행을 조인시키는 기능을 합니다. 전체 행 개수는 두 테이블의 각 행의 개수를 곱한 수 입니다.        Self Join          자체 조인은 자기 자신과 조인하므로 1개의 테이블을 사용합니다.      사용 예시예시 1  한국 음식의 주문별 결제수단과 수수료율을 조회하기select f.order_id,         f.restaurant_name,         f.price,         p.pay_type,         p.vat  from food_orders f left join payments p on f.order_id=p.order_id  where cuisine_type='Korean';            order_id      restaurant_name      price      pay_type      vat                  1477147      Hangawi      30750      card      0.25              1476856      Woorijip      8250      card      0.1              1477600      Hangawi      6740      cash      0.25              1478363      Cho Dang Gol      29250      card      0.2              1477302      Dons Bogam BBQ &amp; Wine Bar      12230      card      0.2      예시 2  주문 가격과 수수료율을 곱하여 주문별 수수료 구하기  조회 컬럼: 주문번호, 식당이름, 주문가격, 수수료율, 수수료) 수수료가 있는 경우만 조회select f.order_id,         f.restaurant_name,         f.price,         p.vat,         (f.price * p.vat) as '수수료'  from food_orders f inner join payments p on f.order_id=p.order_id            order_id      restaurant_name      price      vat      수수료                  1477147      Hangawi      30750      0.25      7687.5              1477685      Blue Ribbon Sushi Izakaya      12080      0.13      1570.3999423980713              1477070      Cafe Habana      12230      0.1      1223.0000182241201              1477334      Blue Ribbon Fried Chicken      29200      0.13      3795.99986076355              1478249      Dirty Bird to Go      11590      0.1      1159.0000172704458      "
  },
  
  {
    "title": "SQL Grammer (7) - Subquery",
    "url": "/posts/SQL-Grammer-(7)-Subquery/",
    "categories": "MySQL, SQL Grammer",
    "tags": "MySQL",
    "date": "2024-03-12 00:00:00 +0900",
    





    
    "snippet": "SQL Grammer (7) - SubquerySubquery여러번의 연산을 수행해야할 때, 조건문에 연산 결과를 사용하거나 조건에 Query결과를 사용하고 싶을 때 쓸 수 있는 문법입니다. 복잡한 쿼리문을 효율적으로 작성할 수 있습니다. 기본 구조는 아래와 같습니다.select column1, testfrom (\t#subquery\tselect col...",
    "content": "SQL Grammer (7) - SubquerySubquery여러번의 연산을 수행해야할 때, 조건문에 연산 결과를 사용하거나 조건에 Query결과를 사용하고 싶을 때 쓸 수 있는 문법입니다. 복잡한 쿼리문을 효율적으로 작성할 수 있습니다. 기본 구조는 아래와 같습니다.select column1, testfrom (\t#subquery\tselect column1, column2 as test\tfrom table1) subq예시ex 1) 음식점의 총 주문수량과 주문금액을 연산하고, 주문수량을 기반으로 수수료 할인율 구하기  할인조건: 수량 5개 이하-&gt; 10%, 수량 15개 초과 &amp; 총 주문금액 300000이상 - 0.5%, 이외 1%select restaurant_name,         case when sum_quantity&lt;=5 then 10              when sum_quantity&gt;15 and total_price&gt;=300000 then 0.5              else 1 end as \"수수료 할인률\"  from(  select restaurant_name,         sum(quantity) as sum_quantity,         sum(price) as total_price  from food_orders  group by 1  ) a;            restaurant_name      수수료 할인률                  Hangawi      10.0              Blue Ribbon Sushi Izakaya      0.5              Cafe Habana      1.0              Blue Ribbon Fried Chicken      0.5              Dirty Bird to Go      1.0      ex 2) 음식 타입별 총 주문수량과 음식점 수를 연산하고, 주문 수량과 음식점 수 별 수수료율 산정하기  음식점수 5개이상, 주문수 30개이상 - 0.05%  5개이상 30개미만 - 0.08%  5개미만, 30개이상 - 1%  5개미만, 30개미만 - 2%select cuisine_type,          total_quantity,          count_restaurant,          case when count_restaurant&gt;=5 and total_quantity&gt;= 30 then 0.005              when count_restaurant&gt;=5 and total_quantity&lt; 30 then 0.008              when count_restaurant&lt;5 and total_quantity&gt;= 30 then 0.01              when count_restaurant&lt;5 and total_quantity&lt;= 30 then 0.02              end rate  from  (select cuisine_type,          sum(quantity) as 'total_quantity',          count(distinct restaurant_name) 'count_restaurant'   from food_orders   group by 1   ) a;            cuisine_type      total_quantity      count_restaurant      rate                  American      1763      41      0.005              Chinese      635      16      0.005              French      57      3      0.010              Indian      186      14      0.005              Italian      900      31      0.005      "
  },
  
  {
    "title": "SQL Grammer (6) - If, Case, Cast",
    "url": "/posts/SQL-Grammer-(6)-If,-Case,-Cast/",
    "categories": "MySQL, SQL Grammer",
    "tags": "MySQL",
    "date": "2024-03-12 00:00:00 +0900",
    





    
    "snippet": "SQL Grammer (6) - If, Case, CastIf조건에 따라 다른 방법을 적용해 값을 얻고 싶을 때 If문을 사용합니다. if(조건, 참일 때 실행, 거짓일 때 실\u001c행)의 형태로 사용합니다. 음식의 타입이 “Korean”이면 한식, 아니면 기타를 출력하는 예시입니다.select restaurant_name,         cuisine_t...",
    "content": "SQL Grammer (6) - If, Case, CastIf조건에 따라 다른 방법을 적용해 값을 얻고 싶을 때 If문을 사용합니다. if(조건, 참일 때 실행, 거짓일 때 실\u001c행)의 형태로 사용합니다. 음식의 타입이 “Korean”이면 한식, 아니면 기타를 출력하는 예시입니다.select restaurant_name,         cuisine_type \"원래 음식 타입\",         if(cuisine_type='Korean', '한식', '기타') \"음식 타입\"  from food_orders;            Hangawi      Korean      한식              Blue Ribbon Sushi Izakaya      Japanese      기타              Cafe Habana      Mexican      기타              Blue Ribbon Fried Chicken      American      기타              Dirty Bird to Go      American      기타      Case조건을 지정하다보면 두개 이상의 조건을 지정해야 할 경우가 있는데, 이러한 때에는 case문이 더 효율적입니다.case when '조건1' then '값1'     when '조건2' then '값2'      ...     else '값3'end의 형태로 사용할 수 있습니다.ex) 10세 이상 30세 미만의 고의 나이와 성로 그룹 나누기(이름도 같이 출력)select case when age between 10 and 19 and gender='male' then '10대 남성'              when age between 10 and 19 and gender='female' then '10대 여성'              when age between 20 and 29 and gender='male' then '20대 남성'              when age between 20 and 29 and gender='female' then '20대 여성'              end as \"고객 분류\",              name, age, gender  from customers  where age between 10 and 29;            고객 분류      name      age      gender              10대 남성      김도진      15      male              10대 여성      정지은      15      female              20대 남성      김하호      21      male              10대 여성      이채원      16      female              10대 여성      박민연      12      female      CastType에 관련한 문제가 발생했을 때 데이터베이스의 값의 타입을 변경해 줄 수 있는 문법입니다.문자 -&gt; 숫자 or 숫자 -&gt; 문자 등cast(컬럼 as 타입)의 형태로 사용가능합니다."
  },
  
  {
    "title": "SQL Grammer (5) - Replace, Substring, Concat",
    "url": "/posts/SQL-Grammer-(5)-Replace,-Substring,-Concat/",
    "categories": "MySQL, SQL Grammer",
    "tags": "MySQL",
    "date": "2024-03-12 00:00:00 +0900",
    





    
    "snippet": "SQL Grammer (5) - Replace, Substring, ConcatReplace특정 문자를 변경하고자 할 때 사용합니다. Replace(바꿀컬럼, 현재 값, 바꿀 값) 의 형태로 사용할 수 있습니다.ex)SELECT restaurant_name AS \"원래 이름\",         REPLACE (restaurant_name, 'Blue',...",
    "content": "SQL Grammer (5) - Replace, Substring, ConcatReplace특정 문자를 변경하고자 할 때 사용합니다. Replace(바꿀컬럼, 현재 값, 바꿀 값) 의 형태로 사용할 수 있습니다.ex)SELECT restaurant_name AS \"원래 이름\",         REPLACE (restaurant_name, 'Blue', 'Pink')  FROM food_orders  WHERE restaurant_name LIKE '%Blue Ribbon%'이렇게 하면 기존에 ‘Blue’ 였던 문자가 Pink로 바뀌게 됩니다.            원래이름      바뀐이름              Blue Ribbon Sushi Izakaya      Pink Ribbon Sushi Izakaya              Blue Ribbon Fried Chicken      Pink Ribbon Fried Chicken              Blue Ribbon Fried Chicken      Pink Ribbon Fried Chicken              Blue Ribbon Sushi Izakaya      Pink Ribbon Sushi Izakaya              Blue Ribbon Sushi      Pink Ribbon Sushi              Blue Ribbon Sushi      Pink Ribbon Sushi      Substring특정 문자만 골라서 조회할 수 있는 문법입니다. substr(조회할 컬럼, 시작 위치, 글자 수)의 형태로 사용 가능합니다. 전체 주소에서 앞의 두글자만 추출하고 싶을 때 쓸 수 있습니다 (“서울특별시”에서 “서울”만 추출). 글자 수를 입력하지 않으면 시작위치에서 끝까지 출력됩니다.SELECT addr as \"원래주소\",SUBSTR(addr, 1,2) FROM food_orders            서울특별시 종로구 팔판      서울              경기도 광주시 퇴촌면      경기              경기도 용인시 처인구 양지면 식금리      경기              경기도 인천시 간석동      경기              경기도 평택군 고덕면 문곡리      경기      Concat여러 컬럼에 나눠져있는 문자를 합쳐야할 때 사용할 수 있는 문법입니다. concat(붙이고 싶은 값1, 붙이고 싶은 값2, ...) 의 형태로 사용 가능합니다. “서울특별시”, “음식점” 형태의 값을 [서울] 음식점명으로 변경하고 싶을 때 사용할 수 있습니다.SELECT restaurant_name as \"원래이름\",         CONCAT('[', SUBSTR(addr,1,2), '] ', restaurant_name)  FROM  food_orders  WHERE addr like '%서울%';            Hangawi      [서울] Hangawi              Barbounia      [서울] Barbounia              Empanada Mama (closed)      [서울] Empanada Mama (closed)              The Meatball Shop      [서울] The Meatball Shop              Blue Ribbon Sushi      [서울] Blue Ribbon Sushi              The Meatball Shop      [서울] The Meatball Shop      연습문제  [지역(시도)] 음식점이름(음식종류) 컬럼을 만들고, 총 주문건수 구하기SELECT concat('[' , substr(addr,1,2) ,'] ', restaurant_name, '(', cuisine_type, ')') as \"음식점 상세\",         count(1) as \"총 주문건수\"  from food_orders  group by restaurant_name;  출력 결과            [서울] Hangawi(Korean)      2              [경기] Blue Ribbon Sushi Izakaya(Japanese)      29              [경기] Cafe Habana(Mexican)      16              [경기] Blue Ribbon Fried Chicken(American)      96              [경기] Dirty Bird to Go(American)      4              [경기] Tamarind TriBeCa(Indian)      27              …      …      "
  },
  
  {
    "title": "SQL Grammer (4) - Group By, Order By",
    "url": "/posts/SQL-Grammer-(4)-Group-By,-Order-By/",
    "categories": "MySQL, SQL Grammer",
    "tags": "MySQL",
    "date": "2024-03-12 00:00:00 +0900",
    





    
    "snippet": "SQL Grammer (4) - Group By, Order ByGroup By데이터를 범주별로 연산된 결과를 얻고 싶을 때 주로 사용합니다. Count, AVG, Sum등의 함수들과 주로 같이 사용되며, 예를들어 나라별 음식 판매의 합산 금액을 구하고 싶을때 사용할 수 있습니다.ex)select cuisine_type,       sum(price)...",
    "content": "SQL Grammer (4) - Group By, Order ByGroup By데이터를 범주별로 연산된 결과를 얻고 싶을 때 주로 사용합니다. Count, AVG, Sum등의 함수들과 주로 같이 사용되며, 예를들어 나라별 음식 판매의 합산 금액을 구하고 싶을때 사용할 수 있습니다.ex)select cuisine_type,       sum(price) sum_of_pricefrom food_ordersgroup by cuisine_type  출력            cuisine_type      sum_of_price                  Korean      182020              Japanese      7663130              Mexican      1303850              American      9530780      Order By지정한 칼럼을 기준으로 정렬된 값을 얻고 싶을 때 사용하는 문법입니다. 기본 오름차순으로 정렬되며 desc를 사용하면 내림차순으로 정렬할 수 있습니다. Group by의 예시의 바로 아래에 order by sum(price)를 입력해줌으로써 합산된 가격의 오름차순으로 정렬된 값을 얻을 수 있습니다. 내림차순은 order by sum(price) desc를 입력해주면 됩니다.ex)select cuisine_type,       sum(price) sum_of_pricefrom food_ordersgroup by cuisine_typeorder by sum(price)   출력            cuisine_type      sum_of_price                  Vietnamese      90180              Korean      182020              Spanish      227930              Southern      328110              French      356290      "
  },
  
  {
    "title": "SQL Grammer (3) - SUM, AVG, COUNT, MIN, MAX",
    "url": "/posts/SQL-Grammer-(3)-SUM,-AVG,-COUNT,-MIN,-MAX/",
    "categories": "MySQL, SQL Grammer",
    "tags": "MySQL",
    "date": "2024-03-11 00:00:00 +0900",
    





    
    "snippet": "SQL Grammer (3) - SUM, AVG, COUNT, MIN, MAXSUM선택된 열과 범위의 합계를 반환해줍니다. 예시처럼 customer의 테이블안에 있는 모든 값들의 나이를 더한 값을 얻고 싶을 때 쓸 수 있습니다.ex)SELECT SUM(age) FROM customersAVGsum과 같은 방법으로 사용 가능하며, 평균 값을 구할 때 사...",
    "content": "SQL Grammer (3) - SUM, AVG, COUNT, MIN, MAXSUM선택된 열과 범위의 합계를 반환해줍니다. 예시처럼 customer의 테이블안에 있는 모든 값들의 나이를 더한 값을 얻고 싶을 때 쓸 수 있습니다.ex)SELECT SUM(age) FROM customersAVGsum과 같은 방법으로 사용 가능하며, 평균 값을 구할 때 사용합니다. customer 테이블 안의 age의 평균값을 구하고 싶다면 다음과 같이 사용할 수 있습니다.SELECT AVG(age) FROM customersCOUNT데이터의 개수를 구하는데 사용할 수 있습니다. ()안에 1이나 *을 입력하면 해당 테이블의 전체 카운트를 가져옵니다. distinct를 사용하면 중복되지 않는 값을 반환합니다. 예시를 보면 customer_id가 중복되지 않는 값을 반환합니다.SELECT COUNT(1) FROM customersSELECT COUNT(*) FROM customersSELECT COUNT(*),COUNT(DISTINCT customer_id) FROM food_ordersMIN선택된 범위 내에서 최소값을 가져오는 문법입니다. “나이가 가장 어린사람”을 찾고 싶을 때 사용 가능합니다.SELECT MIN(age) FROM customersMAX선택된 범위 내에서 최대값을 가져오는 문법입니다. “나이가 가장 많은사람”을 찾고 싶을 때 사용 가능합니다.SELECT MAX(age) FROM customers"
  },
  
  {
    "title": "SQL Grammer (2) - Where, Between, In,",
    "url": "/posts/SQL-Grammer-(2)-Where,-Between,-In,-Like/",
    "categories": "MySQL, SQL Grammer",
    "tags": "MySQL",
    "date": "2024-03-11 00:00:00 +0900",
    





    
    "snippet": "SQL Grammer (2) - Where, Between, In,Where데이터 중에 특정 조건으로 필터링을 해야할 때 사용하는 문법입니다. “나이가 20살 이상인 사람”과 같은 경우의 데이터를 구할 때 사용합니다.ex)SELECT * FROM customer WHERE age&gt;=20Where를 사용할 때 기본적인 비교 연산자로는 =, &lt;...",
    "content": "SQL Grammer (2) - Where, Between, In,Where데이터 중에 특정 조건으로 필터링을 해야할 때 사용하는 문법입니다. “나이가 20살 이상인 사람”과 같은 경우의 데이터를 구할 때 사용합니다.ex)SELECT * FROM customer WHERE age&gt;=20Where를 사용할 때 기본적인 비교 연산자로는 =, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=이 있습니다            연산자      \u001d의미                  =      \b같다              &lt;&gt;      같지않다              &gt;      크다              &gt;=      크거나 같다              &lt;      작다              &lt;=      작거나 같다      Betweena와 b값의 사이에 있는 값을 가져올 때 사용합니다. a와 b 사이에 AND를 사용해 줍니다.ex)SELECT * FROM customer WHERE age BETWEEN 20 and 30In포함하는 조건을 줄 때 사용합니다. “나이가(20, 21, 27)살인 사람”을 필터링할 때 사용합니다.SELECT * FROM customer WHERE age IN(20, 21, 27)Like완전히 똑같지는 않지만 비슷한 값을 찾을 때 사용할 수 있습니다. 예를들어 이름이 ‘OO현’인 사람을 \b찾을때 사용할 수 있습니다. Like연산자와 %, _가 같이 사용되는데, 이 문자들을 WildCard라고 합니다. %는 0,1 또는 하나 이상의 character를 나타냅니다. _는 하나의 character를 나타냅니다.SELECT * FROM customer WHERE name LIKE \"%현\"SELECT * FROM customer WHERE name LIKE \"_현_\"결과를 출력해보면  김예현, 이동현…  김현재, 이현호…가 될 수 있습니다."
  },
  
  {
    "title": "SQL Grammer (1) - Select, From",
    "url": "/posts/SQL-Grammer-(1)-Select,-From/",
    "categories": "MySQL, SQL Grammer",
    "tags": "MySQL",
    "date": "2024-03-11 00:00:00 +0900",
    





    
    "snippet": "SQL Grammer (1) - Select, FromSQL 이란?SQL은 Structured Query Language의 약자이며 직역하자면 구조화된 질의 언어 라는 의미입니다. 관계형 데이터베이스에서 데이터를 관리하고 처리하기 위해 사용되는 비절차적인 언어입니다.SQL 문장에는 다음 3가지 종류가 있습니다.  데이터 정의어(Data Definiti...",
    "content": "SQL Grammer (1) - Select, FromSQL 이란?SQL은 Structured Query Language의 약자이며 직역하자면 구조화된 질의 언어 라는 의미입니다. 관계형 데이터베이스에서 데이터를 관리하고 처리하기 위해 사용되는 비절차적인 언어입니다.SQL 문장에는 다음 3가지 종류가 있습니다.  데이터 정의어(Data Definition Language)  데이터 조작어(Data Manipulation Language)  데이터 제어어(Data Control Language)SelectSelect는 SQL에서 가장 많이 사용되는 구문입니다. 데이터를 가져오는 기본 명령어로, 데이터를 조회하는 모든 Query에 사용됩니다. 단순하게 데이터베이스가 엑셀처럼 행과 열(row) 열(column)이 있다고 했을 때, 열(column)을 선택한다고 생각할 수 있습니다.#모든 열을 선택SELECT * FromFrom은 데이터베이스 안에서 데이터를 가져올 테이블을 특정해주는 문법입니다.SELECT * FROM customer  이에 따라 위의 sql문을 해석하면, 현재 데이터베이스의 customer 테이블의 모든 열을 가져오는 코드가 됩니다.  출력 예시            customer_id      name      email                  337525      조현아      xzvnliwj@hanmail.com              358141      장민호      byuvhegb@hanmail.com              66393      김도진      dzelcyxr@daum.net      "
  },
  
  {
    "title": "Basic70 수열과 구간 쿼리 1",
    "url": "/posts/ProgrammersBasic-70/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-07 00:00:00 +0900",
    





    
    "snippet": "문제: 수열과 구간 쿼리 1문제: 수열과 구간 쿼리 1문제 설명정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [s, e] 꼴입니다.각 query마다 순서대로 s ≤ i ≤ e인 모든 i에 대해 arr[i]에 1을 더합니다.위 규칙에 따라 queries를 처리한 이후의 arr...",
    "content": "문제: 수열과 구간 쿼리 1문제: 수열과 구간 쿼리 1문제 설명정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [s, e] 꼴입니다.각 query마다 순서대로 s ≤ i ≤ e인 모든 i에 대해 arr[i]에 1을 더합니다.위 규칙에 따라 queries를 처리한 이후의 arr를 return 하는 solution 함수를 완성해 주세요.제한사항  1 ≤ arr의 길이 ≤ 1,000          0 ≤ arr의 원소 ≤ 1,000,000        1 ≤ queries의 길이 ≤ 1,000          0 ≤ s ≤ e &lt; arr의 길이      입출력 예            arr      queries      result                  [0, 1, 2, 3, 4]      [[0, 1],[1, 2],[2, 3]]      [1, 3, 4, 4, 4]      입출력 예 설명입출력 예 #1  각 쿼리에 따라 arr가 다음과 같이 변합니다.            i      queries[i]      arr                  -      -      [0, 1, 2, 3, 4]              0      [0,1]      [1, 2, 2, 3, 4]              1      [1,2]      [1, 3, 3, 3, 4]              2      [2,3]      [1, 3, 4, 4, 4]        따라서 [1, 3, 4, 4, 4]를 return 합니다.Solution  먼저 queries.reduce(into: arr)을 사용해서 arr을 reduce의 초기값으로 넣어주었습니다.queries.reduce(into: arr){ result, q in }  그런 다음 arr.indices.filter를 사용해서 index의 값이 queries의 범위에 있는 index들을 뽑아낸 다음 그에 해당하는 요소에 += 1를 해주는 방법으로 문제를 풀었습니다.import Foundationfunc solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {    return queries.reduce(into: arr){ result, q in        arr.indices.filter{$0 &gt;= q[0] &amp;&amp; $0 &lt;= q[1]}.map{result[$0] += 1}    }}"
  },
  
  {
    "title": "Basic69 n 보다 커질 때까지 더하기",
    "url": "/posts/ProgrammersBasic-69/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-07 00:00:00 +0900",
    





    
    "snippet": "문제: n 보다 커질 때까지 더하기문제 설명정수 배열 numbers와 정수 n이 매개변수로 주어집니다. numbers의 원소를 앞에서부터 하나씩 더하다가 그 합이 n보다 커지는 순간 이때까지 더했던 원소들의 합을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ numbers의 길이 ≤ 100  1 ≤ numbers의 원소 ≤ ...",
    "content": "문제: n 보다 커질 때까지 더하기문제 설명정수 배열 numbers와 정수 n이 매개변수로 주어집니다. numbers의 원소를 앞에서부터 하나씩 더하다가 그 합이 n보다 커지는 순간 이때까지 더했던 원소들의 합을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ numbers의 길이 ≤ 100  1 ≤ numbers의 원소 ≤ 100  0 ≤ n &lt; numbers의 모든 원소의 합입출력 예            numbers      n      result                  [34, 5, 71, 29, 100, 34]      123      139              [58, 44, 27, 10, 100]      139      239      입출력 예 설명입출력 예 #1      예제 1번의 numbers를 문제 설명대로 더해가는 과정을 나타내면 다음의 표와 같습니다.                            i          numbers[i]          sum                                                            0                          0          34          34                          1          5          39                          2          71          110                          3          29          139                      29를 더한 뒤에 sum 값은 139이고 n 값인 123보다 크므로 139를 return 합니다.        예제 2번의 numbers의 마지막 원소 전까지의 원소를 sum에 더하면 139입니다. 139는 n 값인 139보다 크지 않고 마지막 원소인 100을 더하면 139보다 커지므로 239를 return 합니다.  Solution  주어진 조건에 맞춰서 while문을 통해 numbers의 값들을 더하다가 reuslt가 n보다 커지는 순간 break를 통해서 result를 반환하는 방식으로 문제를 풀었습니다.import Foundationfunc solution(_ numbers:[Int], _ n:Int) -&gt; Int {    var result = 0    var index = 0    while true {\t    if result &gt; n {            break        }        result += numbers[index]        index += 1    }    return result}  이를 짧게 reduce를 활용해서, 처음 주어진 $0의 값이 n보다 작으면 $0 + $1을 해줌으로써 값을 더해주고, $0 &gt; n이 되면 $0을 더이상 더해주지 않는 방법으로도 문제를 풀어봤습니다.    return numbers.reduce(0){$0 &gt; n ? $0 : $0 + $1}"
  },
  
  {
    "title": "Basic68 할 일 목록",
    "url": "/posts/ProgrammersBasic-68/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-07 00:00:00 +0900",
    





    
    "snippet": "문제: 할 일 목록문제 설명오늘 해야 할 일이 담긴 문자열 배열 todo_list와 각각의 일을 지금 마쳤는지를 나타내는 boolean 배열 finished가 매개변수로 주어질 때, todo_list에서 아직 마치지 못한 일들을 순서대로 담은 문자열 배열을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ todo_list의 길...",
    "content": "문제: 할 일 목록문제 설명오늘 해야 할 일이 담긴 문자열 배열 todo_list와 각각의 일을 지금 마쳤는지를 나타내는 boolean 배열 finished가 매개변수로 주어질 때, todo_list에서 아직 마치지 못한 일들을 순서대로 담은 문자열 배열을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ todo_list의 길이 1 ≤ 100  2 ≤ todo_list의 원소의 길이 ≤ 20          todo_list의 원소는 영소문자로만 이루어져 있습니다.      todo_list의 원소는 모두 서로 다릅니다.        finished[i]는 true 또는 false이고 true는 todo_list[i]를 마쳤음을, false는 아직 마치지 못했음을 나타냅니다.  아직 마치지 못한 일이 적어도 하나 있습니다.입출력 예            todo_list      finished      result                  [“problemsolving”, “practiceguitar”, “swim”, “studygraph”]      [true, false, true, false]      [“practiceguitar”, “studygraph”]      입출력 예 설명입출력 예 #1  예제 1번의 todo_list 중에서 “problemsolving”과 “swim”은 마쳤고, “practiceguitar”와 “studygraph”는 아직 마치지 못했으므로 todo_list에서 나온 순서대로 담은 문자열 배열 [“practiceguitar”, “studygraph”]를 return 합니다.Solution  todo_list와 finished가 같은 index 값을 갖기 때문에, enumerated()를 이용해서 finished 중 값이 false인 요소들을 뽑아낸 후에, 그 인덱스를 활용해 todo_list의 남은 할 일 들을 담은 배열을 만들었습니다.import Foundationfunc solution(_ todo_list:[String], _ finished:[Bool]) -&gt; [String] {    return finished.enumerated().filter{$0.element == false}.map{ todo_list[$0.offset] }}"
  },
  
  {
    "title": "Basic67 5명씩",
    "url": "/posts/ProgrammersBasic-67/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-07 00:00:00 +0900",
    





    
    "snippet": "문제: 5명씩문제 설명최대 5명씩 탑승가능한 놀이기구를 타기 위해 줄을 서있는 사람들의 이름이 담긴 문자열 리스트 names가 주어질 때, 앞에서 부터 5명씩 묶은 그룹의 가장 앞에 서있는 사람들의 이름을 담은 리스트를 return하도록 solution 함수를 완성해주세요. 마지막 그룹이 5명이 되지 않더라도 가장 앞에 있는 사람의 이름을 포함합니다....",
    "content": "문제: 5명씩문제 설명최대 5명씩 탑승가능한 놀이기구를 타기 위해 줄을 서있는 사람들의 이름이 담긴 문자열 리스트 names가 주어질 때, 앞에서 부터 5명씩 묶은 그룹의 가장 앞에 서있는 사람들의 이름을 담은 리스트를 return하도록 solution 함수를 완성해주세요. 마지막 그룹이 5명이 되지 않더라도 가장 앞에 있는 사람의 이름을 포함합니다.제한사항  5 ≤ names의 길이 ≤ 30  1 ≤ names의 원소의 길이 ≤ 10  names의 원소는 영어 알파벳 소문자로만 이루어져 있습니다.입출력 예            names      result                  [“nami”, “ahri”, “jayce”, “garen”, “ivern”, “vex”, “jinx”]      [“nami”, “vex”]      입출력 예 설명입출력 예 #1  앞에서부터 5명씩 두 그룹으로 묶을 수 있습니다. [“nami”, “ahri”, “jayce”, “garen”, “ivern”], [“vex”, “jinx”] 이 두 그룹에서 가장 앞에 서있는 사람들의 이름을 담은 리스트인 [“nami”, “vex”]를 return합니다.Solution  indices.filter와 % 연산자를 사용해서 각각 그룹의 제일 앞사람의 인덱스 값을 뽑아서 map으로 이름을 배열에 담아 return 했습니다.import Foundationfunc solution(_ names:[String]) -&gt; [String] {    return names.indices.filter{$0 % 5 == 0}.map{names[$0]}}"
  },
  
  {
    "title": "Basic66 홀수 vs 짝수",
    "url": "/posts/ProgrammersBasic-66/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-07 00:00:00 +0900",
    





    
    "snippet": "문제: 홀수 vs 짝수문제 설명정수 리스트 num_list가 주어집니다. 가장 첫 번째 원소를 1번 원소라고 할 때, 홀수 번째 원소들의 합과 짝수 번째 원소들의 합 중 큰 값을 return 하도록 solution 함수를 완성해주세요. 두 값이 같을 경우 그 값을 return합니다.제한사항  5 ≤ num_list의 길이 ≤ 50  -9 ≤ num_l...",
    "content": "문제: 홀수 vs 짝수문제 설명정수 리스트 num_list가 주어집니다. 가장 첫 번째 원소를 1번 원소라고 할 때, 홀수 번째 원소들의 합과 짝수 번째 원소들의 합 중 큰 값을 return 하도록 solution 함수를 완성해주세요. 두 값이 같을 경우 그 값을 return합니다.제한사항  5 ≤ num_list의 길이 ≤ 50  -9 ≤ num_list의 원소 ≤ 9입출력 예            num_list      result                  [4, 2, 6, 1, 7, 6]      17              [-1, 2, 5, 6, 3]      8      입출력 예 설명입출력 예 #1  홀수 번째 원소들의 합은 4 + 6 + 7 = 17, 짝수 번째 원소들의 합은 2 + 1 + 6 = 9 이므로 17을 return합니다.입출력 예 #2  홀수 번째 원소들의 합은 -1 + 5 + 3 = 7, 짝수 번째 원소들의 합은 2 + 6 = 8 이므로 8을 return합니다.※2023년 04월 24일 테스트 케이스가 추가되었습니다. 기존에 제출한 코드가 통과하지 못할 수 있습니다.Solution  홀수 번째 원소들을 indices.filter를 통해 구하고, 그 합을 reduce를 사용해 구합니다. 짝수도 같은 방법으로 구현합니다.num_list.indices.filter{$0 % 2 == 0}.reduce(0){$0 + num_list[$1]}num_list.indices.filter{$0 % 2 != 0}.reduce(0){$0 + num_list[$1]}  max 함수를 이용해서 둘 중 큰값을 return 합니다.import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {    return max(num_list.indices.filter{$0 % 2 == 0}.reduce(0){$0 + num_list[$1]}, num_list.indices.filter{$0 % 2 != 0}.reduce(0){$0 + num_list[$1]})}"
  },
  
  {
    "title": "Basic65 n개 간격의 원소들",
    "url": "/posts/ProgrammersBasic-65/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-06 00:00:00 +0900",
    





    
    "snippet": "문제: n개 간격의 원소들문제 설명정수 리스트 num_list와 정수 n이 주어질 때, num_list의 첫 번째 원소부터 마지막 원소까지 n개 간격으로 저장되어있는 원소들을 차례로 담은 리스트를 return하도록 solution 함수를 완성해주세요.제한사항  5 ≤ num_list의 길이 ≤ 20  1 ≤ num_list의 원소 ≤ 9  1 ≤ n ...",
    "content": "문제: n개 간격의 원소들문제 설명정수 리스트 num_list와 정수 n이 주어질 때, num_list의 첫 번째 원소부터 마지막 원소까지 n개 간격으로 저장되어있는 원소들을 차례로 담은 리스트를 return하도록 solution 함수를 완성해주세요.제한사항  5 ≤ num_list의 길이 ≤ 20  1 ≤ num_list의 원소 ≤ 9  1 ≤ n ≤ 4입출력 예            num_list      n      result                  [4, 2, 6, 1, 7, 6]      2      [4, 6, 7]              [4, 2, 6, 1, 7, 6]      4      [4, 7]      입출력 예 설명입출력 예 #1  [4, 2, 6, 1, 7, 6]에서 2개 간격으로 저장되어 있는 원소들은 [4, 6, 7]입니다.입출력 예 #2  [4, 2, 6, 1, 7, 6]에서 4개 간격으로 저장되어 있는 원소들은 [4, 7]입니다.Solution  filter와 % 연산자를 사용해서 n개의 간격으로 원소를 걸러내는 코드를 구현했습니다.import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; [Int] {    return num_list.enumerated().filter{$0.offset % n == 0}.map{$0.element}}  다른 방법으로는 stride를 이용해서 n개의 간격으로 원소를 담는 코드를 구현할 수 있습니다.import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; [Int] {    return stride(from:0 , to: num_list.count, by: n).map{num_list[$0]}}"
  },
  
  {
    "title": "Basic64 n 번째 원소까지",
    "url": "/posts/ProgrammersBasic-64/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-06 00:00:00 +0900",
    





    
    "snippet": "문제: n 번째 원소까지문제 설명정수 리스트 num_list와 정수 n이 주어질 때, num_list의 첫 번째 원소부터 n 번째 원소까지의 모든 원소를 담은 리스트를 return하도록 solution 함수를 완성해주세요.제한사항  2 ≤ num_list의 길이 ≤ 30  1 ≤ num_list의 원소 ≤ 9  1 ≤ n ≤ num_list의 길이 _...",
    "content": "문제: n 번째 원소까지문제 설명정수 리스트 num_list와 정수 n이 주어질 때, num_list의 첫 번째 원소부터 n 번째 원소까지의 모든 원소를 담은 리스트를 return하도록 solution 함수를 완성해주세요.제한사항  2 ≤ num_list의 길이 ≤ 30  1 ≤ num_list의 원소 ≤ 9  1 ≤ n ≤ num_list의 길이 ___입출력 예            num_list      n      result                  [2, 1, 6]      1      [2]              [5, 2, 1, 7, 5]      3      [5, 2, 1]      입출력 예 설명입출력 예 #1  [2, 1, 6]의 첫 번째 원소부터 첫 번째 원소까지의 모든 원소는 [2]입니다.입출력 예 #2  [5, 2, 1, 7, 5]의 첫 번째 원소부터 세 번째 원소까지의 모든 원소는 [5, 2, 1]입니다.Solution  [0..&lt;n]을 사용해서 배열의 구간을 나누어 문제를 풀었습니다.`참고: num_list[0..&lt;n]의 반환타입은 ‘ArraySlice'이므로 map을 사용해 [Int] 타입으로 변환해주어야 합니다.import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; [Int] {    return num_list[0..&lt;n].map{$0}}"
  },
  
  {
    "title": "Basic63 왼쪽 오른쪽",
    "url": "/posts/ProgrammersBasic-63/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-06 00:00:00 +0900",
    





    
    "snippet": "문제: 왼쪽 오른쪽문제 설명문자열 리스트 str_list에는 “u”, “d”, “l”, “r” 네 개의 문자열이 여러 개 저장되어 있습니다. str_list에서 “l”과 “r” 중 먼저 나오는 문자열이 “l”이라면 해당 문자열을 기준으로 왼쪽에 있는 문자열들을 순서대로 담은 리스트를, 먼저 나오는 문자열이 “r”이라면 해당 문자열을 기준으로 오른쪽에 ...",
    "content": "문제: 왼쪽 오른쪽문제 설명문자열 리스트 str_list에는 “u”, “d”, “l”, “r” 네 개의 문자열이 여러 개 저장되어 있습니다. str_list에서 “l”과 “r” 중 먼저 나오는 문자열이 “l”이라면 해당 문자열을 기준으로 왼쪽에 있는 문자열들을 순서대로 담은 리스트를, 먼저 나오는 문자열이 “r”이라면 해당 문자열을 기준으로 오른쪽에 있는 문자열들을 순서대로 담은 리스트를 return하도록 solution 함수를 완성해주세요. “l”이나 “r”이 없다면 빈 리스트를 return합니다.제한사항  1 ≤ str_list의 길이 ≤ 20  str_list는 “u”, “d”, “l”, “r” 네 개의 문자열로 이루어져 있습니다.입출력 예            str_list      result                  [“u”, “u”, “l”, “r”]      [“u”, “u”]              [“l”]      []      입출력 예 설명입출력 예 #1  “r”보다 “l”이 먼저 나왔기 때문에 “l”의 왼쪽에 있는 문자열들을 담은 리스트인 [“u”, “u”]를 return합니다.입출력 예 #2  “l”의 왼쪽에 문자열이 없기 때문에 빈 리스트를 return합니다.Solution  왼쪽, 오른쪽의 기준이 될 값을 찾기 위해서 filter를 사용해 값이 r, l 인 요소들을 걸러낸 후 그 중 첫 번째 값을 piviot 변수에 저장했습니다. if let을 이용해서 만약 값이 없을 경우는 빈 리스트를 리턴하도록 했습니다.if let pivot = str_list.enumerated().filter{$0.element == \"r\" || $0.element == \"l\"}.first{}else {\t  return []}  이후에는 pivot의 값이 l 인지 r 인지에 따라서 문제의 요구사항 대로 리스트를 만들어 return해주는 코드를 작성했습니다.import Foundationfunc solution(_ str_list:[String]) -&gt; [String] {    if let pivot = str_list.enumerated().filter{$0.element == \"r\" || $0.element == \"l\"}.first {        return pivot.element == \"l\" ? str_list[0..&lt;pivot.offset].map{$0} : str_list[(pivot.offset+1)...].map{$0}    }    else {        return []    }}"
  },
  
  {
    "title": "Basic62 순서 바꾸기",
    "url": "/posts/ProgrammersBasic-62/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-06 00:00:00 +0900",
    





    
    "snippet": "문제: 순서 바꾸기문제 설명정수 리스트 num_list와 정수 n이 주어질 때, num_list를 n 번째 원소 이후의 원소들과 n 번째까지의 원소들로 나눠 n 번째 원소 이후의 원소들을 n 번째까지의 원소들 앞에 붙인 리스트를 return하도록 solution 함수를 완성해주세요.제한사항  2 ≤ num_list의 길이 ≤ 30  1 ≤ num_li...",
    "content": "문제: 순서 바꾸기문제 설명정수 리스트 num_list와 정수 n이 주어질 때, num_list를 n 번째 원소 이후의 원소들과 n 번째까지의 원소들로 나눠 n 번째 원소 이후의 원소들을 n 번째까지의 원소들 앞에 붙인 리스트를 return하도록 solution 함수를 완성해주세요.제한사항  2 ≤ num_list의 길이 ≤ 30  1 ≤ num_list의 원소 ≤ 9  1 ≤ n ≤ num_list의 길이입출력 예            num_list      n      result                  [2, 1, 6]      1      [1, 6, 2]              [5, 2, 1, 7, 5]      3      [7, 5, 5, 2, 1]      입출력 예 설명입출력 예 #1  [2, 1, 6]에서 첫 번째 이후의 원소는 [1, 6]이고 첫 번째까지의 원소는 [2]입니다. 두 리스트를 이어 붙이면 [1, 6, 2]가 됩니다.입출력 예 #2  [5, 2, 1, 7, 5]에서 세 번째 이후의 원소는 [7, 5]이고 세 번째까지의 원소는 [5, 2, 1]입니다. 두 리스트를 이어 붙이면 [7, 5, 5, 2, 1]가 됩니다.Solution  하나의 배열을 0번째부터 n번째 까지의 배열과, n번째부터 끝까지의 배열 두개로 나눕니다. 그 후 같은 타입의 배열 + 배열은 두 배열을 하나로 합치는 특성을 이용해 문제를 풀었습니다.import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; [Int] {        return num_list[n...].map{$0} + num_list[0..&lt;n].map{$0}}"
  },
  
  {
    "title": "Basic61 n 번째 원소부터",
    "url": "/posts/ProgrammersBasic-61/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-06 00:00:00 +0900",
    





    
    "snippet": "문제: n 번째 원소부터문제 설명정수 리스트 num_list와 정수 n이 주어질 때, n 번째 원소부터 마지막 원소까지의 모든 원소를 담은 리스트를 return하도록 solution 함수를 완성해주세요.제한사항  2 ≤ num_list의 길이 ≤ 30  1 ≤ num_list의 원소 ≤ 9  1 ≤ n ≤ num_list의 길이입출력 예        ...",
    "content": "문제: n 번째 원소부터문제 설명정수 리스트 num_list와 정수 n이 주어질 때, n 번째 원소부터 마지막 원소까지의 모든 원소를 담은 리스트를 return하도록 solution 함수를 완성해주세요.제한사항  2 ≤ num_list의 길이 ≤ 30  1 ≤ num_list의 원소 ≤ 9  1 ≤ n ≤ num_list의 길이입출력 예            num_list      n      result                  [2, 1, 6]      3      [6]              [5, 2, 1, 7, 5]      2      [2, 1, 7, 5]      입출력 예 설명입출력 예 #1  [2, 1, 6]의 세 번째 원소부터 마지막 원소까지의 모든 원소는 [6]입니다.입출력 예 #2  [5, 2, 1, 7, 5]의 두 번째 원소부터 마지막 원소까지의 모든 원소는 [2, 1, 7, 5]입니다.Solution  [n-1...] 을 사용해서 배열의 구간을 나누어 return 했습니다.import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; [Int] {    let num = n - 1    return num_list[num...].map{$0}}"
  },
  
  {
    "title": "Basic60 배열 조각하기",
    "url": "/posts/ProgrammersBasic-60/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-05 00:00:00 +0900",
    





    
    "snippet": "문제: 배열 조각하기문제 설명정수 배열 arr와 query가 주어집니다.query를 순회하면서 다음 작업을 반복합니다.  짝수 인덱스에서는 arr에서 query[i]번 인덱스를 제외하고 배열의 query[i]번 인덱스 뒷부분을 잘라서 버립니다.  홀수 인덱스에서는 arr에서 query[i]번 인덱스는 제외하고 배열의 query[i]번 인덱스 앞부분을 ...",
    "content": "문제: 배열 조각하기문제 설명정수 배열 arr와 query가 주어집니다.query를 순회하면서 다음 작업을 반복합니다.  짝수 인덱스에서는 arr에서 query[i]번 인덱스를 제외하고 배열의 query[i]번 인덱스 뒷부분을 잘라서 버립니다.  홀수 인덱스에서는 arr에서 query[i]번 인덱스는 제외하고 배열의 query[i]번 인덱스 앞부분을 잘라서 버립니다.위 작업을 마친 후 남은 arr의 부분 배열을 return 하는 solution 함수를 완성해 주세요.제한사항  5 ≤ arr의 길이 ≤ 100,000          0 ≤ arr의 원소 ≤ 100        1 ≤ query의 길이 &lt; min(50, arr의 길이 / 2)          query의 각 원소는 0보다 크거나 같고 남아있는 arr의 길이 보다 작습니다.      입출력 예            arr      query      result                  [0, 1, 2, 3, 4, 5]      [4, 1, 2]      [1, 2, 3]      입출력 예 설명입출력 예 #1  이번에 매번 처리할 query의 값과 처리 전후의 arr의 상태를 표로 나타내면 다음과 같습니다.            query의 값      query 처리 전      query 처리 후      비고                  4      [0, 1, 2, 3, 4, 5]      [0, 1, 2, 3, 4]      0번 인덱스의 쿼리이므로 뒷부분을 자른다.              1      [0, 1, 2, 3, 4]      [1, 2, 3, 4]      1번 인덱스의 쿼리이므로 앞부분을 자른다.              2      [1, 2, 3, 4]      [1, 2, 3]      2번 인덱스의 쿼리이므로 뒷부분을 자른다.        따라서 [1, 2, 3]을 return 합니다.Solution  \breduce(into:)를 이용해서 먼저 arr을 초기값으로 넣어주었고, query의 요소가 짝수라면 [0...q]로 slice를 해주고 홀수라면 [q...]를 적용시켜주었습니다.import Foundationfunc solution(_ arr:[Int], _ query:[Int]) -&gt; [Int] {    var index = 0    return query.reduce(into: arr) { result, q in        index % 2 == 0 ? result = result[0...q].map{$0} : result = result[q...].map{$0}        index += 1    }}"
  },
  
  {
    "title": "Basic59 2의 영역",
    "url": "/posts/ProgrammersBasic-59/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-05 00:00:00 +0900",
    





    
    "snippet": "문제: 2의 영역문제 설명정수 배열 arr가 주어집니다. 배열 안의 2가 모두 포함된 가장 작은 연속된 부분 배열을 return 하는 solution 함수를 완성해 주세요.단, arr에 2가 없는 경우 [-1]을 return 합니다.제한사항  1 ≤ arr의 길이 ≤ 100,000          1 ≤ arr의 원소 ≤ 10      입출력 예   ...",
    "content": "문제: 2의 영역문제 설명정수 배열 arr가 주어집니다. 배열 안의 2가 모두 포함된 가장 작은 연속된 부분 배열을 return 하는 solution 함수를 완성해 주세요.단, arr에 2가 없는 경우 [-1]을 return 합니다.제한사항  1 ≤ arr의 길이 ≤ 100,000          1 ≤ arr의 원소 ≤ 10      입출력 예            arr      result                  [1, 2, 1, 4, 5, 2, 9]      [2, 1, 4, 5, 2]              [1, 2, 1]      [2]              [1, 1, 1]      [-1]              [1, 2, 1, 2, 1, 10, 2, 1]      [2, 1, 2, 1, 10, 2]      입출력 예 설명입출력 예 #1  2가 있는 인덱스는 1번, 5번 인덱스뿐이므로 1번부터 5번 인덱스까지의 부분 배열인 [2, 1, 4, 5, 2]를 return 합니다.입출력 예 #2  2가 한 개뿐이므로 [2]를 return 합니다.입출력 예 #3  2가 배열에 없으므로 [-1]을 return 합니다.입출력 예 #4  2가 있는 인덱스는 1번, 3번, 6번 인덱스이므로 1번부터 6번 인덱스까지의 부분 배열인 [2, 1, 2, 1, 10, 2]를 return 합니다.\bSolution  enumerated().filter를 사용해서 값이 2인 요소들만 뽑아내어 그 index값을 구합니다. 그 중에 가장 앞에있는 요소와 가장 뒤에있는 요소를 찾아내어 arr를 slice해서 return해주었습니다.import Foundationfunc solution(_ arr:[Int]) -&gt; [Int] {    let indices = arr.enumerated().filter{$0.element == 2}.map{$0.offset}    let first = indices.first ?? -1    let last = indices.last ?? -1        return first == -1 ? [-1] : arr[first...last].map{$0}}"
  },
  
  {
    "title": "Basic58 배열 만들기 3",
    "url": "/posts/ProgrammersBasic-58/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-05 00:00:00 +0900",
    





    
    "snippet": "문제: 배열 만들기 3문제 설명정수 배열 arr와 2개의 구간이 담긴 배열 intervals가 주어집니다.intervals는 항상 [[a1, b1], [a2, b2]]의 꼴로 주어지며 각 구간은 닫힌 구간입니다. 닫힌 구간은 양 끝값과 그 사이의 값을 모두 포함하는 구간을 의미합니다.이때 배열 arr의 첫 번째 구간에 해당하는 배열과 두 번째 구간에 ...",
    "content": "문제: 배열 만들기 3문제 설명정수 배열 arr와 2개의 구간이 담긴 배열 intervals가 주어집니다.intervals는 항상 [[a1, b1], [a2, b2]]의 꼴로 주어지며 각 구간은 닫힌 구간입니다. 닫힌 구간은 양 끝값과 그 사이의 값을 모두 포함하는 구간을 의미합니다.이때 배열 arr의 첫 번째 구간에 해당하는 배열과 두 번째 구간에 해당하는 배열을 앞뒤로 붙여 새로운 배열을 만들어 return 하는 solution 함수를 완성해 주세요.제한사항  1 ≤ arr의 길이 ≤ 100,000          1 ≤ arr의 원소 &lt; 100        1 ≤ a1 ≤ b1 &lt; arr의 길이  1 ≤ a2 ≤ b2 &lt; arr의 길이입출력 예            arr      intervals      result                  [1, 2, 3, 4, 5]      [[1, 3], [0, 4]]      [2, 3, 4, 1, 2, 3, 4, 5]      입출력 예 설명입출력 예 #1  첫 번째 구간에 해당하는 배열은 [2, 3, 4] 입니다.  두 번째 구간에 해당하는 배열은 [1, 2, 3, 4, 5] 입니다.  따라서 이 두 배열을 앞뒤로 붙인 배열인 [2, 3, 4, 1, 2, 3, 4, 5]를 return 합니다.Solution  intervals에 map을 접근한 요소의 값으로 arr을 나누어서 각각 intervals의 값이 요구하는 배열을 생성합니다. 입출력 예를 입력으로 print해보면 아래와 같습니다.[ArraySlice([2, 3, 4]), ArraySlice([1, 2, 3, 4, 5])]이제 이 배열들을 reduce를 사용해서 하나의 배열로 만들었습니다. reduce의 $0으로 들어가게 되는 ()안의 값이 [] 빈 배열이 되면 배열끼리 더하는 코드를 작성할 수 있게 됩니다.import Foundationfunc solution(_ arr:[Int], _ intervals:[[Int]]) -&gt; [Int] {    return intervals.map{arr[$0[0]...$0[1]]}.reduce([]){$0+$1}}"
  },
  
  {
    "title": "Basic57 첫 번째로 나오는 음수",
    "url": "/posts/ProgrammersBasic-57/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-04 00:00:00 +0900",
    





    
    "snippet": "문제: 첫 번째로 나오는 음수문제 설명정수 리스트 num_list가 주어질 때, 첫 번째로 나오는 음수의 인덱스를 return하도록 solution 함수를 완성해주세요. 음수가 없다면 -1을 return합니다.제한사항  5 ≤ num_list의 길이 ≤ 100  -10 ≤ num_list의 원소 ≤ 100입출력 예            num_list ...",
    "content": "문제: 첫 번째로 나오는 음수문제 설명정수 리스트 num_list가 주어질 때, 첫 번째로 나오는 음수의 인덱스를 return하도록 solution 함수를 완성해주세요. 음수가 없다면 -1을 return합니다.제한사항  5 ≤ num_list의 길이 ≤ 100  -10 ≤ num_list의 원소 ≤ 100입출력 예            num_list      result                  [12, 4, 15, 46, 38, -2, 15]      5              [13, 22, 53, 24, 15, 6]      -1      입출력 예 설명입출력 예 #1  5번 인덱스에서 음수가 처음 등장하므로 5를 return합니다.입출력 예 #2  음수가 없으므로 -1을 return합니다.Solution  index를 리턴해야하기 때문에 enumerated를 사용했고, 값이 음수인 경우의 첫번째 인덱스를 리턴, 없다면 -1을 리턴하게 코드를 작성했습니다.import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {    return num_list.enumerated().filter{index, value in value &lt; 0}.map{$0.offset}.first ?? -1}"
  },
  
  {
    "title": "Basic56 리스트 자르기",
    "url": "/posts/ProgrammersBasic-56/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-03 00:00:00 +0900",
    





    
    "snippet": "문제: 리스트 자르기문제 설명정수 n과 정수 3개가 담긴 리스트 slicer 그리고 정수 여러 개가 담긴 리스트 num_list가 주어집니다. slicer에 담긴 정수를 차례대로 a, b, c라고 할 때, n에 따라 다음과 같이 num_list를 슬라이싱 하려고 합니다.  n = 1 : num_list의 0번 인덱스부터 b번 인덱스까지  n = 2 :...",
    "content": "문제: 리스트 자르기문제 설명정수 n과 정수 3개가 담긴 리스트 slicer 그리고 정수 여러 개가 담긴 리스트 num_list가 주어집니다. slicer에 담긴 정수를 차례대로 a, b, c라고 할 때, n에 따라 다음과 같이 num_list를 슬라이싱 하려고 합니다.  n = 1 : num_list의 0번 인덱스부터 b번 인덱스까지  n = 2 : num_list의 a번 인덱스부터 마지막 인덱스까지  n = 3 : num_list의 a번 인덱스부터 b번 인덱스까지  n = 4 : num_list의 a번 인덱스부터 b번 인덱스까지 c 간격으로올바르게 슬라이싱한 리스트를 return하도록 solution 함수를 완성해주세요.제한사항  n 은 1, 2, 3, 4 중 하나입니다.  slicer의 길이 = 3      slicer에 담긴 정수를 차례대로 a, b, c라고 할 때          0 ≤ a ≤ b ≤ num_list의 길이 - 1       1 ≤ c ≤ 3            5 ≤ num_list의 길이 ≤ 30    0 ≤ num_list의 원소 ≤ 100입출력 예            n      slicer      num_list      result                  3      [1, 5, 2]      [1, 2, 3, 4, 5, 6, 7, 8, 9]      [2, 3, 4, 5, 6]              4      [1, 5, 2]      [1, 2, 3, 4, 5, 6, 7, 8, 9]      [2, 4, 6]      입출력 예 설명입출력 예 #1  [1, 2, 3, 4, 5, 6, 7, 8, 9]에서 1번 인덱스부터 5번 인덱스까지 자른 리스트는 [2, 3, 4, 5, 6]입니다.입출력 예 #2  [1, 2, 3, 4, 5, 6, 7, 8, 9]에서 1번 인덱스부터 5번 인덱스까지 2개 간격으로 자른 리스트는 [2, 4, 6]입니다.Solution  switch case로 n의 4가지 경우를 구분하고, 각각 조건에 맞게 구현했습니다. n이 4일 때 c 간격으로를 구현하는 방법은 여러가지가 있겠지만, %연산자를 이용해서 구했습니다.import Foundationfunc solution(_ n:Int, _ slicer:[Int], _ num_list:[Int]) -&gt; [Int] {    let (a, b, c) = (slicer[0], slicer[1], slicer[2])    switch n {        case 1:            return num_list[0...b].map{$0}        case 2:            return num_list[a...].map{$0}        case 3:            return num_list[a...b].map{$0}        case 4:            return num_list[a...b].indices.filter{$0%c == 0}.map{num_list[$0]}        default:            return [0]    }}"
  },
  
  {
    "title": "Basic55 가까운 1 찾기",
    "url": "/posts/ProgrammersBasic-55/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-02 00:00:00 +0900",
    





    
    "snippet": "문제: 가까운 1 찾기문제 설명정수 배열 arr가 주어집니다. 이때 arr의 원소는 1 또는 0입니다. 정수 idx가 주어졌을 때, idx보다 크면서 배열의 값이 1인 가장 작은 인덱스를 찾아서 반환하는 solution 함수를 완성해 주세요.단, 만약 그러한 인덱스가 없다면 -1을 반환합니다.제한사항  3 ≤ arr의 길이 ≤ 100’000      ...",
    "content": "문제: 가까운 1 찾기문제 설명정수 배열 arr가 주어집니다. 이때 arr의 원소는 1 또는 0입니다. 정수 idx가 주어졌을 때, idx보다 크면서 배열의 값이 1인 가장 작은 인덱스를 찾아서 반환하는 solution 함수를 완성해 주세요.단, 만약 그러한 인덱스가 없다면 -1을 반환합니다.제한사항  3 ≤ arr의 길이 ≤ 100’000          arr의 원소는 전부 1 또는 0입니다.       입출력 예            arr      idx      result                  [0, 0, 0, 1]      1      3              [1, 0, 0, 1, 0, 0]      4      -1              [1, 1, 1, 1, 0]      3      3      입출력 예 설명입출력 예 #1  1보다 크면서 원소가 1인 가장 작은 인덱스는 3입니다. 따라서 3을 return 합니다.입출력 예 #2  4번 인덱스 이후에 1은 등장하지 않습니다. 따라서 -1을 return 합니다.입출력 예 #3  3번 인덱스의 값이 1입니다. 따라서 3을 return 합니다.Solution``  arr를 idx 부터 끝까지의 배열을 추출해 냅니다. enumerated를 사용해서 index와 element를 받아오고 그중 element가 1인 요소들을 filter를 사용해 걸러냅니다. 그 중의 최초 값을 반환하는데 만약 없다면 -1을 반환합니다. 현재 이 배열의 index는 idx앞의 값들을 제외하고 0부터 시작했기 때문에 idx를 마지막에 더해줍니다.import Foundationfunc solution(_ arr:[Int], _ idx:Int) -&gt; Int {    return (arr[idx...].enumerated().filter{$0.element == 1}.map{$0.offset}.first ?? -1-idx) + idx}"
  },
  
  {
    "title": "Basic54 카운트 다운",
    "url": "/posts/ProgrammersBasic-54/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-02 00:00:00 +0900",
    





    
    "snippet": "문제: 카운트 다운문제 설명정수 start_num와 end_num가 주어질 때, start_num에서 end_num까지 1씩 감소하는 수들을 차례로 담은 리스트를 return하도록 solution 함수를 완성해주세요.제한사항  0 ≤ end_num ≤ start_num ≤ 50입출력 예            start_num      end_num   ...",
    "content": "문제: 카운트 다운문제 설명정수 start_num와 end_num가 주어질 때, start_num에서 end_num까지 1씩 감소하는 수들을 차례로 담은 리스트를 return하도록 solution 함수를 완성해주세요.제한사항  0 ≤ end_num ≤ start_num ≤ 50입출력 예            start_num      end_num      result                  10      3      [10, 9, 8, 7, 6, 5, 4, 3]      입출력 예 설명입출력 예 #1  10부터 3까지 1씩 감소하는 수를 담은 리스트는 [10, 9, 8, 7, 6, 5, 4, 3]입니다.Solutionimport Foundationfunc solution(_ start:Int, _ end_num:Int) -&gt; [Int] {    return (end_num...start).sorted(by: &gt;)}"
  },
  
  {
    "title": "Basic53 글자 지우기",
    "url": "/posts/ProgrammersBasic-53/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-02-01 00:00:00 +0900",
    





    
    "snippet": "문제: 글자 지우기문제 설명문자열 my_string과 정수 배열 indices가 주어질 때, my_string에서 indices의 원소에 해당하는 인덱스의 글자를 지우고 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ indices의 길이 &lt; my_string의 길이 ≤ 100  my_string은 영...",
    "content": "문제: 글자 지우기문제 설명문자열 my_string과 정수 배열 indices가 주어질 때, my_string에서 indices의 원소에 해당하는 인덱스의 글자를 지우고 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ indices의 길이 &lt; my_string의 길이 ≤ 100  my_string은 영소문자로만 이루어져 있습니다  0 ≤ indices의 원소 &lt; my_string의 길이  indices의 원소는 모두 서로 다릅니다.입출력 예            my_string      indices      result                  “apporoograpemmemprs”      [1, 16, 6, 15, 0, 10, 11, 3]      “programmers”      입출력 예 설명입출력 예 #1      예제 1번의 my_string의 인덱스가 잘 보이도록 표를 만들면 다음과 같습니다.                            index          0          1          2          3          4          5          6          7          8          9          10          11          12          13          14          15          16          17          18                                      my_string          a          p          p          o          r          o          o          g          r          a          p          e          m          m          e          m          p          r          s                      indices에 있는 인덱스의 글자들을 지우고 이어붙이면 “programmers”가 되므로 이를 return 합니다.  Solution  \b처음에 아래 코드처럼 바로 remove(at:) 을 사용했는데, 이렇게 할 경우에는 중간에 있는 글자가 지워지면, 전체 길이가 짧아지고, 동시에 지워진 글자 뒤의 글자들의 index가 바뀌어서 제대로된 결과를 얻지 못했습니다.func solution(_ my_string:String, _ indices:[Int]) -&gt; String {\tvar result = Array(my_string)\tresult.map{result.remove(at: $0)}}  따라서, 주어진 indices를 내림차순으로 정렬시켜서 글자를 맨 뒤에서부터 지워나가서 인덱스 변화에 영향을 받지 않도록 코드를 작성했습니다.import Foundationfunc solution(_ my_string:String, _ indices:[Int]) -&gt; String {    var result = Array(my_string)    var sortedIndices = indices.sorted(by: &gt;)        sortedIndices.map{result.remove(at: $0)}        return String(result)} "
  },
  
  {
    "title": "Basic52 배열 만들기 1",
    "url": "/posts/ProgrammersBasic-52/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-27 00:00:00 +0900",
    





    
    "snippet": "문제: 배열 만들기 1문제 설명정수 n과 k가 주어졌을 때, 1 이상 n이하의 정수 중에서 k의 배수를 오름차순으로 저장한 배열을 return 하는 solution 함수를 완성해 주세요.제한사항  1 ≤ n ≤ 1,000,000  1 ≤ k ≤ min(1,000, n)입출력 예            n      k      result          ...",
    "content": "문제: 배열 만들기 1문제 설명정수 n과 k가 주어졌을 때, 1 이상 n이하의 정수 중에서 k의 배수를 오름차순으로 저장한 배열을 return 하는 solution 함수를 완성해 주세요.제한사항  1 ≤ n ≤ 1,000,000  1 ≤ k ≤ min(1,000, n)입출력 예            n      k      result                  10      3      [3, 6, 9]              15      5      [5, 10, 15]      입출력 예 설명입출력 예 #1  1 이상 10 이하의 3의 배수는 3, 6, 9 이므로 [3, 6, 9]를 return 합니다.입출력 예 #2  1 이상 15 이하의 5의 배수는 5, 10, 15 이므로 [5, 10, 15]를 return 합니다.Solutionimport Foundationfunc solution(_ n:Int, _ k:Int) -&gt; [Int] {        return (1...n).filter{$0 % k == 0}}"
  },
  
  {
    "title": "Basic51 문자 개수 세기",
    "url": "/posts/ProgrammersBasic-51/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-26 00:00:00 +0900",
    





    
    "snippet": "문제: 문자 개수 세기문제 설명알파벳 대소문자로만 이루어진 문자열 my_string이 주어질 때, my_string에서 ‘A’의 개수, my_string에서 ‘B’의 개수,…, my_string에서 ‘Z’의 개수, my_string에서 ‘a’의 개수, my_string에서 ‘b’의 개수,…, my_string에서 ‘z’의 개수를 순서대로 담은 길이 5...",
    "content": "문제: 문자 개수 세기문제 설명알파벳 대소문자로만 이루어진 문자열 my_string이 주어질 때, my_string에서 ‘A’의 개수, my_string에서 ‘B’의 개수,…, my_string에서 ‘Z’의 개수, my_string에서 ‘a’의 개수, my_string에서 ‘b’의 개수,…, my_string에서 ‘z’의 개수를 순서대로 담은 길이 52의 정수 배열을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ my_string의 길이 ≤ 1,000입출력 예            my_string      result                  “Programmers”      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 3, 1, 0, 0, 0, 0, 0, 0, 0]      입출력 예 설명입출력 예 #1  예제 1번의 my_string에서 ‘P’가 1개, ‘a’가 1개, ‘e’가 1개, ‘g’가 1개, ‘m’이 2개, ‘o’가 1개, ‘r’가 3개, ‘s’가 1개 있으므로 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 3, 1, 0, 0, 0, 0, 0, 0, 0]를 return 합니다.Solution  ascii코드의 값을 이용해서 문제를 풀었습니다. 대문자 알파벳은 65~90까지이고, 소문자 알파벳은 97~122입니다.      길이 52의 0이담긴 result 배열을 만듭니다. 0부터 25 인덱스 까지는 대문자, 26부터 51까지는 소문자의 인덱스입니다.    my_string의 각 문자들을 돌면서 ascii코드 값이 91 미만이라면 대문자, 이상이면 소문자라고 판멸합니다.    대문자라면 65로 나눈 나머지를 구하고, 소문자라면 97로 나눈 나머지에 26을 더해서 각 알파벳의 인덱스를 찾습니다.    result 배열에 인덱스 자리에 1을 더해줍니다.  import Foundationfunc solution(_ my_string:String) -&gt; [Int] {    var result = Array(repeating:0, count: 52)    my_string.map{ Int($0.asciiValue!) &lt; 91 ? Int($0.asciiValue!) % 65 : Int($0.asciiValue!) % 97 + 26}.map{result[$0] += 1}    return result}"
  },
  
  {
    "title": "Basic50 qr code",
    "url": "/posts/ProgrammersBasic-50/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-25 00:00:00 +0900",
    





    
    "snippet": "문제: qr code문제 설명두 정수 q, r과 문자열 code가 주어질 때, code의 각 인덱스를 q로 나누었을 때 나머지가 r인 위치의 문자를 앞에서부터 순서대로 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  0 ≤ r &lt; q ≤ 20  r &lt; code의 길이 ≤ 1,000  code는 영소문자로...",
    "content": "문제: qr code문제 설명두 정수 q, r과 문자열 code가 주어질 때, code의 각 인덱스를 q로 나누었을 때 나머지가 r인 위치의 문자를 앞에서부터 순서대로 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  0 ≤ r &lt; q ≤ 20  r &lt; code의 길이 ≤ 1,000  code는 영소문자로만 이루어져 있습니다.입출력 예            q      r      code      result                  3      1      “qjnwezgrpirldywt”      “jerry”              1      0      “programmers”      “programmers”      입출력 예 설명입출력 예 #1      예제 1번의 q와 r은 각각 3, 1이고 인덱스와 그 값을 q로 나눈 나머지가 잘 보이도록 표로 만들면 다음과 같습니다.                            code          q          j          n          w          e          z          g          r          p          i          r          l          d          y          w          t                                      index          0          1          2          3          4          5          6          7          8          9          10          11          12          13          14          15                          q로 나눈 나머지          0          1          2          0          1          2          0          1          2          0          1          2          0          1          2          0                      q로 나눈 나머지가 1인 인덱스의 문자들을 앞에서부터 순서대로 이어 붙이면 “jerry”가 되므로 이를 return 합니다.  입출력 예 #2      예제 2번의 q와 r은 각각 1, 0이고 인덱스와 그 값을 q로 나눈 나머지가 잘 보이도록 표로 만들면 다음과 같습니다.                            code          p          r          o          g          r          a          m          m          e          r          s                                      index          0          1          2          3          4          5          6          7          8          9          10                          q로 나눈 나머지          0          0          0          0          0          0          0          0          0          0          0                      q로 나눈 나머지가 1인 인덱스의 문자들을 앞에서부터 순서대로 이어 붙이면 “programmers”가 되므로 이를 return 합니다.  Solution  enumerated().filter와 map을 사용해서 문제를 풀었습니다.import Foundationfunc solution(_ q:Int, _ r:Int, _ code:String) -&gt; String {    return String(code.enumerated().filter{index, value in index % q == r}.map{$0.element})}"
  },
  
  {
    "title": "Basic49 세로 읽기",
    "url": "/posts/ProgrammersBasic-49/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-25 00:00:00 +0900",
    





    
    "snippet": "문제: 세로 읽기문제 설명문자열 my_string과 두 정수 m, c가 주어집니다. my_string을 한 줄에 m 글자씩 가로로 적었을 때 왼쪽부터 세로로 c번째 열에 적힌 글자들을 문자열로 return 하는 solution 함수를 작성해 주세요.제한사항  my_string은 영소문자로 이루어져 있습니다.  1 ≤ m ≤ my_string의 길이 ≤...",
    "content": "문제: 세로 읽기문제 설명문자열 my_string과 두 정수 m, c가 주어집니다. my_string을 한 줄에 m 글자씩 가로로 적었을 때 왼쪽부터 세로로 c번째 열에 적힌 글자들을 문자열로 return 하는 solution 함수를 작성해 주세요.제한사항  my_string은 영소문자로 이루어져 있습니다.  1 ≤ m ≤ my_string의 길이 ≤ 1,000  m은 my_string 길이의 약수로만 주어집니다.  1 ≤ c ≤ m입출력 예            my_string      m      c      result                  “ihrhbakrfpndopljhygc”      4      2      “happy”              “programmers”      1      1      “programmers”      입출력 예 설명입출력 예 #1      예제 1번의 my_string을 한 줄에 4 글자씩 쓰면 다음의 표와 같습니다.                            1열          2열          3열          4열                                      i          h          r          h                          b          a          k          r                          f          p          n          d                          o          p          l          j                          h          y          g          c                      2열에 적힌 글자를 세로로 읽으면 happy이므로 “happy”를 return 합니다.  입출력 예 #2  예제 2번의 my_string은 m이 1이므로 세로로 “programmers”를 적는 것과 같고 따라서 1열에 적힌 글자를 세로로 읽으면 programmers입니다. 따라서 “programmers”를 return 합니다.Solution  my_string의 각각 index의 값을 m으로 나누었을 때의 나머지 값은 2차원 배열로 봤을 때 열의 값과 같습니다. 이를 이용해서 문제를 풀었습니다.import Foundationfunc solution(_ my_string:String, _ m:Int, _ c:Int) -&gt; String {    var strArray = Array(my_string)    return String(strArray.indices.filter{$0 % m == c-1}.map{strArray[$0]})}"
  },
  
  {
    "title": "Basic48 문자열 뒤집기",
    "url": "/posts/ProgrammersBasic-48/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-25 00:00:00 +0900",
    





    
    "snippet": "문제: 문자열 뒤집기문제 설명문자열 my_string과 정수 s, e가 매개변수로 주어질 때, my_string에서 인덱스 s부터 인덱스 e까지를 뒤집은 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  my_string은 숫자와 알파벳으로만 이루어져 있습니다.  1 ≤ my_string의 길이 ≤ 1,000  0 ≤ s ≤ ...",
    "content": "문제: 문자열 뒤집기문제 설명문자열 my_string과 정수 s, e가 매개변수로 주어질 때, my_string에서 인덱스 s부터 인덱스 e까지를 뒤집은 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  my_string은 숫자와 알파벳으로만 이루어져 있습니다.  1 ≤ my_string의 길이 ≤ 1,000  0 ≤ s ≤ e &lt; my_string의 길이입출력 예            my_string      s      e      result                  “Progra21Sremm3”      6      12      “ProgrammerS123”              “Stanley1yelnatS”      4      10      “Stanley1yelnatS”      입출력 예 설명입출력 예 #1  예제 1번의 my_string에서 인덱스 6부터 인덱스 12까지를 뒤집은 문자열은 “ProgrammerS123”이므로 “ProgrammerS123”를 return 합니다.입출력 예 #2  예제 2번의 my_string에서 인덱스 4부터 인덱스 10까지를 뒤집으면 원래 문자열과 같은 “Stanley1yelnatS”이므로 “Stanley1yelnatS”를 return 합니다.Solution  my_string을 Array로 변환해주고, Array에 s부터 e까지를 reverse한 후에 다시 String으로 변환해주었습니다.import Foundationfunc solution(_ my_string:String, _ s:Int, _ e:Int) -&gt; String {    var strArray = Array(my_string)    strArray[s...e].reverse()        return String(strArray)}"
  },
  
  {
    "title": "Basic47 접두사인지 확인하기",
    "url": "/posts/ProgrammersBasic-47/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-25 00:00:00 +0900",
    





    
    "snippet": "문제: 접두사인지 확인하기문제 설명어떤 문자열에 대해서 접두사는 특정 인덱스까지의 문자열을 의미합니다. 예를 들어, “banana”의 모든 접두사는 “b”, “ba”, “ban”, “bana”, “banan”, “banana”입니다.문자열 my_string과 is_prefix가 주어질 때, is_prefix가 my_string의 접두사라면 1을, 아니...",
    "content": "문제: 접두사인지 확인하기문제 설명어떤 문자열에 대해서 접두사는 특정 인덱스까지의 문자열을 의미합니다. 예를 들어, “banana”의 모든 접두사는 “b”, “ba”, “ban”, “bana”, “banan”, “banana”입니다.문자열 my_string과 is_prefix가 주어질 때, is_prefix가 my_string의 접두사라면 1을, 아니면 0을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ my_string의 길이 ≤ 100  1 ≤ is_prefix의 길이 ≤ 100  my_string과 is_prefix는 영소문자로만 이루어져 있습니다.입출력 예            my_string      is_prefix      result                  “banana”      “ban”      1              “banana”      “nan”      0              “banana”      “abcd”      0              “banana”      “bananan”      0      입출력 예 설명입출력 예 #1  예제 1번에서 is_prefix가 my_string의 접두사이기 때문에 1을 return 합니다.입출력 예 #2  예제 2번에서 is_prefix가 my_string의 접두사가 아니기 때문에 0을 return 합니다.입출력 예 #3  예제 3번에서 is_prefix가 my_string의 접두사가 아니기 때문에 0을 return 합니다.입출력 예 #4  예제 4번에서 is_prefix가 my_string의 접두사가 아니기 때문에 0을 return 합니다.Solutionimport Foundationfunc solution(_ my_string:String, _ is_prefix:String) -&gt; Int {    return my_string.prefix(is_prefix.count) == is_prefix ? 1 : 0}"
  },
  
  {
    "title": "Basic46 문자열의 앞의 n글자",
    "url": "/posts/ProgrammersBasic-46/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-25 00:00:00 +0900",
    





    
    "snippet": "문제: 문자열의 앞의 n글자문제 설명문자열 my_string과 정수 n이 매개변수로 주어질 때, my_string의 앞의 n글자로 이루어진 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  my_string은 숫자와 알파벳으로 이루어져 있습니다.  1 ≤ my_string의 길이 ≤ 1,000  1 ≤ n ≤ my_string...",
    "content": "문제: 문자열의 앞의 n글자문제 설명문자열 my_string과 정수 n이 매개변수로 주어질 때, my_string의 앞의 n글자로 이루어진 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  my_string은 숫자와 알파벳으로 이루어져 있습니다.  1 ≤ my_string의 길이 ≤ 1,000  1 ≤ n ≤ my_string의 길이입출력 예            my_string      n      result                  “ProgrammerS123”      11      “ProgrammerS”              “He110W0r1d”      5      “He110”      입출력 예입출력 예 #1  예제 1번의 my_string에서 앞의 11글자는 “ProgrammerS”이므로 이 문자열을 return 합니다.입출력 예 #2  예제 2번의 my_string에서 앞의 5글자는 “He110”이므로 이 문자열을 return 합니다.Solutionimport Foundationfunc solution(_ my_string:String, _ n:Int) -&gt; String {    return String(my_string.prefix(n))}"
  },
  
  {
    "title": "Basic45 접미사인지 확인하기",
    "url": "/posts/ProgrammersBasic-45/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-25 00:00:00 +0900",
    





    
    "snippet": "문제: 접미사인지 확인하기문제 설명어떤 문자열에 대해서 접미사는 특정 인덱스부터 시작하는 문자열을 의미합니다. 예를 들어, “banana”의 모든 접미사는 “banana”, “anana”, “nana”, “ana”, “na”, “a”입니다.문자열 my_string과 is_suffix가 주어질 때, is_suffix가 my_string의 접미사라면 1을...",
    "content": "문제: 접미사인지 확인하기문제 설명어떤 문자열에 대해서 접미사는 특정 인덱스부터 시작하는 문자열을 의미합니다. 예를 들어, “banana”의 모든 접미사는 “banana”, “anana”, “nana”, “ana”, “na”, “a”입니다.문자열 my_string과 is_suffix가 주어질 때, is_suffix가 my_string의 접미사라면 1을, 아니면 0을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ my_string의 길이 ≤ 100  1 ≤ is_suffix의 길이 ≤ 100  my_string과 is_suffix는 영소문자로만 이루어져 있습니다.입출력 예            my_string      is_suffix      result                  “banana”      “ana”      1              “banana”      “nan”      0              “banana”      “wxyz”      0              “banana”      “abanana”      0      입출력 예 설명입출력 예 #1  예제 1번에서 is_suffix가 my_string의 접미사이기 때문에 1을 return 합니다.입출력 예 #2  예제 2번에서 is_suffix가 my_string의 접미사가 아니기 때문에 0을 return 합니다.입출력 예 #3  예제 3번에서 is_suffix가 my_string의 접미사가 아니기 때문에 0을 return 합니다.입출력 예 #4  예제 4번에서 is_suffix가 my_string의 접미사가 아니기 때문에 0을 return 합니다.Solution  \bsuffix 함수를 사용해서 my_string에 is_suffix.count 숫자만큼 suffix를 실행시켜서, 그 값이 is_suffix와 같으면 1 아니면 0 을 반환합니다.import Foundationfunc solution(_ my_string:String, _ is_suffix:String) -&gt; Int {    return is_suffix == my_string.suffix(is_suffix.count) ? 1 : 0}  hasSuffix라는 함수를 찾아서 사용해봤습니다.import Foundationfunc solution(_ my_string:String, _ is_suffix:String) -&gt; Int {    return my_string.hasSuffix(is_suffix) ? 1:0}"
  },
  
  {
    "title": "Basic44 접미사 배열",
    "url": "/posts/ProgrammersBasic-44/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-25 00:00:00 +0900",
    





    
    "snippet": "문제: 접미사 배열문제 설명어떤 문자열에 대해서 접미사는 특정 인덱스부터 시작하는 문자열을 의미합니다. 예를 들어, “banana”의 모든 접미사는 “banana”, “anana”, “nana”, “ana”, “na”, “a”입니다.문자열 my_string이 매개변수로 주어질 때, my_string의 모든 접미사를 사전순으로 정렬한 문자열 배열을 re...",
    "content": "문제: 접미사 배열문제 설명어떤 문자열에 대해서 접미사는 특정 인덱스부터 시작하는 문자열을 의미합니다. 예를 들어, “banana”의 모든 접미사는 “banana”, “anana”, “nana”, “ana”, “na”, “a”입니다.문자열 my_string이 매개변수로 주어질 때, my_string의 모든 접미사를 사전순으로 정렬한 문자열 배열을 return 하는 solution 함수를 작성해 주세요.제한사항  my_string은 알파벳 소문자로만 이루어져 있습니다.  1 ≤ my_string의 길이 ≤ 100입출력 예            my_string      result                  “banana”      [“a”, “ana”, “anana”, “banana”, “na”, “nana”]              “programmers”      [“ammers”, “ers”, “grammers”, “mers”, “mmers”, “ogrammers”, “programmers”, “rammers”, “rogrammers”, “rs”, “s”]      입출력 예 설명입출력 예 #1  예제 1번의 my_string는 “banana”로 모든 접미사는 문제의 설명과 같습니다. 이를 사전순으로 정렬하면 “a”, “ana”, “anana”, “banana”, “na”, “nana”이므로 [“a”, “ana”, “anana”, “banana”, “na”, “nana”]를 return 합니다.입출력 예 #2  예제 2번의 my_string는 “programmers”이고 모든 접미사는 “programmers”, “rogrammers”, “ogrammers”, “grammers”, “rammers”, “ammers”, “mmers”, “mers”, “ers”, “rs”, “s”입니다. 이를 사전순으로 정렬한 문자열 배열 [“ammers”, “ers”, “grammers”, “mers”, “mmers”, “ogrammers”, “programmers”, “rammers”, “rogrammers”, “rs”, “s”]를 return 합니다.Solution  for문과 suffix를 사용해서 문제를 풀었습니다.import Foundationfunc solution(_ my_string:String) -&gt; [String] {    var result = [String]()    for i in 1...my_string.count {        result.append(String(my_string.suffix(i)))    }        return result.sorted()}  이후 map을 사용해서도 문제를 풀어봤습니다.import Foundationfunc solution(_ my_string:String) -&gt; [String] {    return my_string.indices.map{String(my_string.suffix(from: $0))}.sorted()}"
  },
  
  {
    "title": "Basic43 문자열의 뒤의 n글자",
    "url": "/posts/ProgrammersBasic-43/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-25 00:00:00 +0900",
    





    
    "snippet": "문제: 문자열의 뒤의 n글자문제 설명문자열 my_string과 정수 n이 매개변수로 주어질 때, my_string의 뒤의 n글자로 이루어진 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  my_string은 숫자와 알파벳으로 이루어져 있습니다.  1 ≤ my_string의 길이 ≤ 1,000  1 ≤ n ≤ my_string...",
    "content": "문제: 문자열의 뒤의 n글자문제 설명문자열 my_string과 정수 n이 매개변수로 주어질 때, my_string의 뒤의 n글자로 이루어진 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  my_string은 숫자와 알파벳으로 이루어져 있습니다.  1 ≤ my_string의 길이 ≤ 1,000  1 ≤ n ≤ my_string의 길이입출력 예            my_string      n      result                  “ProgrammerS123”      11      “grammerS123”              “He110W0r1d”      5      “W0r1d”      입출력 예입출력 예 #1  예제 1번의 my_string에서 뒤의 11글자는 “grammerS123”이므로 이 문자열을 return 합니다.입출력 예 #2  예제 2번의 my_string에서 뒤의 5글자는 “W0r1d”이므로 이 문자열을 return 합니다.Solutionimport Foundationfunc solution(_ my_string:String, _ n:Int) -&gt; String {    return String(my_string.suffix(n))}"
  },
  
  {
    "title": "Basic42 부분 문자열 이어 붙여 문자열 만들기",
    "url": "/posts/ProgrammersBasic-42/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-24 00:00:00 +0900",
    





    
    "snippet": "문제: 부분 문자열 이어 붙여 문자열 만들기문제 설명길이가 같은 문자열 배열 my_strings와 이차원 정수 배열 parts가 매개변수로 주어집니다. parts[i]는 [s, e] 형태로, my_string[i]의 인덱스 s부터 인덱스 e까지의 부분 문자열을 의미합니다. 각 my_strings의 원소의 parts에 해당하는 부분 문자열을 순서대로 이...",
    "content": "문제: 부분 문자열 이어 붙여 문자열 만들기문제 설명길이가 같은 문자열 배열 my_strings와 이차원 정수 배열 parts가 매개변수로 주어집니다. parts[i]는 [s, e] 형태로, my_string[i]의 인덱스 s부터 인덱스 e까지의 부분 문자열을 의미합니다. 각 my_strings의 원소의 parts에 해당하는 부분 문자열을 순서대로 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ my_strings의 길이 = parts의 길이 ≤ 100  1 ≤ my_strings의 원소의 길이 ≤ 100  parts[i]를 [s, e]라 할 때, 다음을 만족합니다.          0 ≤ s ≤ e &lt; my_strings[i]의 길이      입출력 예            my_strings      parts      result                  [“progressive”, “hamburger”, “hammer”, “ahocorasick”]      [[0, 4], [1, 2], [3, 5], [7, 7]]      “programmers”      입출력 예 설명입출력 예 #1      예제 1번의 입력을 보기 좋게 표로 나타내면 다음과 같습니다.                            i          my_strings[i]          parts[i]          부분 문자열                                      0          “progressive”          [0, 4]          “progr”                          1          “hamburger”          [1, 2]          “am”                          2          “hammer”          [3, 5]          “mer”                          3          “ahocorasick”          [7, 7]          ”s”                      각 부분 문자열을 순서대로 이어 붙인 문자열은 “programmers”입니다. 따라서 “programmers”를 return 합니다.  Solution  이전 배열만들기 5 문제에서 배운 prefix, suffix와 enumerated(),map을 사용해서 문제를 풀었습니다.import Foundationfunc solution(_ my_strings:[String], _ parts:[[Int]]) -&gt; String {    var result = \"\"    parts.enumerated().map{ index, value in        let (s, e) = (value[0], value[1])        result += my_strings[index].prefix(e+1).suffix(e-s+1)    }        return result}"
  },
  
  {
    "title": "Basic41 배열만들기 5",
    "url": "/posts/ProgrammersBasic-41/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-24 00:00:00 +0900",
    





    
    "snippet": "문제: 배열만들기 5문제 설명문자열 배열 intStrs와 정수 k, s, l가 주어집니다. intStrs의 원소는 숫자로 이루어져 있습니다. 배열 intStrs의 각 원소마다 s번 인덱스에서 시작하는 길이 l짜리 부분 문자열을 잘라내 정수로 변환합니다. 이때 변환한 정수값이 k보다 큰 값들을 담은 배열을 return 하는 solution 함수를 완성해...",
    "content": "문제: 배열만들기 5문제 설명문자열 배열 intStrs와 정수 k, s, l가 주어집니다. intStrs의 원소는 숫자로 이루어져 있습니다. 배열 intStrs의 각 원소마다 s번 인덱스에서 시작하는 길이 l짜리 부분 문자열을 잘라내 정수로 변환합니다. 이때 변환한 정수값이 k보다 큰 값들을 담은 배열을 return 하는 solution 함수를 완성해 주세요.제한사항  0 ≤ s &lt; 100  1 ≤ l ≤ 8  10l - 1 ≤ k &lt; 10l  1 ≤ intStrs의 길이 ≤ 10,000          s + l ≤ intStrs의 원소의 길이 ≤ 120      입출력 예            intStrs      k      s      l      result                  [“0123456789”,”9876543210”,”9999999999999”]      50000      5      5      [56789, 99999]      입출력 예 설명입출력 예 #1  idx에 따라 잘라낸 문자열과 그에 따른 ret의 변화를 표시하면 다음 표와 같습니다.            idx      잘라낸 문자열      ret                  0      “56789”      [56789]              1      “43210”      [56789]              2      “99999”      [56789, 99999]        따라서 [56789, 99999]를 return 합니다.Solution  처음에 map, filter를 사용해서 풀려고 노력해봤는데, 풀기는 했지만 코드를 알아보기 어렵고 굉장히 비효율적인 코드가 되었습니다.import Foundationfunc solution(_ intStrs:[String], _ k:Int, _ s:Int, _ l:Int) -&gt; [Int] {    let arr = intStrs.map{ $0.enumerated().filter{$0.offset &gt;= s &amp;&amp; $0.offset &lt; s+l}.map{String($0.element)}.joined()}        return arr.map{Int($0)!}.filter{$0 &gt; k}}  이후 String.prefix(), String.suffix()를 사용해서 문제를 푸는 방법을 알았습니다. prefix(5)는 앞에서 5번째까지의 string값을 가져오는 것이고,suffix(5)는 뒤에서 5번째까지의 string값을 가져오는 함수입니다.import Foundationfunc solution(_ intStrs:[String], _ k:Int, _ s:Int, _ l:Int) -&gt; [Int] {    let result = intStrs.map {Int($0.prefix(s+l).suffix(s))!}.filter{$0 &gt; k}    return result}"
  },
  
  {
    "title": "Basic40 문자열 여러 번 뒤집기",
    "url": "/posts/ProgrammersBasic-40/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-23 00:00:00 +0900",
    





    
    "snippet": "## 문제: 문자열 여러 번 뒤집기 ###### 문제 설명문자열 my_string과 이차원 정수 배열 queries가 매개변수로 주어집니다. queries의 원소는 [s, e] 형태로, my_string의 인덱스 s부터 인덱스 e까지를 뒤집으라는 의미입니다. my_string에 queries의 명령을 순서대로 처리한 후의 문자열을 return 하는 s...",
    "content": "## 문제: 문자열 여러 번 뒤집기 ###### 문제 설명문자열 my_string과 이차원 정수 배열 queries가 매개변수로 주어집니다. queries의 원소는 [s, e] 형태로, my_string의 인덱스 s부터 인덱스 e까지를 뒤집으라는 의미입니다. my_string에 queries의 명령을 순서대로 처리한 후의 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  my_string은 영소문자로만 이루어져 있습니다.  1 ≤ my_string의 길이 ≤ 1,000  queries의 원소는 [s, e]의 형태로 0 ≤ s ≤ e &lt; my_string의 길이를 만족합니다.  1 ≤ queries의 길이 ≤ 1,000입출력 예            my_string      queries      result                  “rermgorpsam”      [[2, 3], [0, 7], [5, 9], [6, 10]]      “programmers”      입출력 예 설명      예제 1번의 my_string은 “rermgorpsam”이고 주어진 queries를 순서대로 처리하면 다음과 같습니다.                            queries          my_string                                                 “rermgorpsam”                          [2, 3]          “remrgorpsam”                          [0, 7]          “progrmersam”                          [5, 9]          “prograsremm”                          [6, 10]          “programmers”                      따라서 “programmers”를 return 합니다.  Solution  처음 풀이는 조금 복잡했습니다. 먼저 my_string을 배열로 만들고, queries에 reduce(into: array)를 사용해서 arr.reversed()를 써서 arr안의 요소들을 뒤집어 주는 방식을 사용했습니다.import Foundationfunc solution(_ my_string:String, _ queries:[[Int]]) -&gt; String {    var array = Array(my_string)    let result = queries.reduce(into: array) { arr, q in        let (s, e) = (q[0], q[1])        let reversedArray = Array(arr[s...e].reversed())        for i in s...e{            arr[i] = reversedArray[i-s]        }            }    return String(result)}  원리는 동일하지만 .reverse() 함수를 알게되어 아래와 같이 코드를 조금 다듬었습니다.func solution(_ my_string:String, _ queries:[[Int]]) -&gt; String {\tvar array = Array(my_string)    let result = queries.reduce(into: array) { arr, q in        arr[q[0]...q[1]].reverse()    }    return String(result)}"
  },
  
  {
    "title": "Basic39 9로 나눈 나머지",
    "url": "/posts/ProgrammersBasic-39/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-23 00:00:00 +0900",
    





    
    "snippet": "문제: 9로 나눈 나머지문제 설명음이 아닌 정수를 9로 나눈 나머지는 그 정수의 각 자리 숫자의 합을 9로 나눈 나머지와 같은 것이 알려져 있습니다.이 사실을 이용하여 음이 아닌 정수가 문자열 number로 주어질 때, 이 정수를 9로 나눈 나머지를 return 하는 solution 함수를 작성해주세요.제한사항  1 ≤ number의 길이 ≤ 100,...",
    "content": "문제: 9로 나눈 나머지문제 설명음이 아닌 정수를 9로 나눈 나머지는 그 정수의 각 자리 숫자의 합을 9로 나눈 나머지와 같은 것이 알려져 있습니다.이 사실을 이용하여 음이 아닌 정수가 문자열 number로 주어질 때, 이 정수를 9로 나눈 나머지를 return 하는 solution 함수를 작성해주세요.제한사항  1 ≤ number의 길이 ≤ 100,000  number의 원소는 숫자로만 이루어져 있습니다.  number는 정수 0이 아니라면 숫자 ‘0’으로 시작하지 않습니다.입출력 예            number      result                  “123”      6              “78720646226947352489”      2      입출력 예 설명입출력 예 #1  예제 1번의 number는 123으로 각 자리 숫자의 합은 6입니다. 6을 9로 나눈 나머지는 6이고, 실제로 123 = 9 × 13 + 6입니다. 따라서 6을 return 합니다.입출력 예 #2  예제 2번의 number는 78720646226947352489으로 각자리 숫자의 합은 101입니다. 101을 9로 나눈 나머지는 2이고, 실제로 78720646226947352489 = 9 × 8746738469660816943 + 2입니다. 따라서 2를 return 합니다.Solution  처음에는 Int(number) % 9를 써봤지만, 큰 숫자가 들어왔을 때 Int에 overflow가 일어나면서 nil을 반환하여 오류가 나는 것을 확인했습니다. 문제의 조건대로 각 자리숫자의 합을 구하고 %연산자로 처리했습니다.import Foundationfunc solution(_ number:String) -&gt; Int {    return number.reduce(0){$0 + Int(String($1))!} % 9}"
  },
  
  {
    "title": "Basic38 글자 이어 붙여 문자열 만들기",
    "url": "/posts/ProgrammersBasic-38/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-23 00:00:00 +0900",
    





    
    "snippet": "문제: 글자 이어 붙여 문자열 만들기문제 설명문자열 my_string과 정수 배열 index_list가 매개변수로 주어집니다. my_string의 index_list의 원소들에 해당하는 인덱스의 글자들을 순서대로 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ my_string의 길이 ≤ 1,000  my_...",
    "content": "문제: 글자 이어 붙여 문자열 만들기문제 설명문자열 my_string과 정수 배열 index_list가 매개변수로 주어집니다. my_string의 index_list의 원소들에 해당하는 인덱스의 글자들을 순서대로 이어 붙인 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ my_string의 길이 ≤ 1,000  my_string의 원소는 영소문자로 이루어져 있습니다.  1 ≤ index_list의 길이 ≤ 1,000  0 ≤ index_list의 원소 &lt; my_string의 길이입출력 예            my_string      index_list      result                  “cvsgiorszzzmrpaqpe”      [16, 6, 5, 3, 12, 14, 11, 11, 17, 12, 7]      “programmers”              “zpiaz”      [1, 2, 0, 0, 3]      “pizza”      입출력 예 설명입출력 예 #1  예제 1번의 my_string에서 인덱스 3, 5, 6, 11, 12, 14, 16, 17에 해당하는 글자는 각각 g, o, r, m, r, a, p, e이므로 my_string에서 index_list에 들어있는 원소에 해당하는 인덱스의 글자들은 각각 순서대로 p, r, o, g, r, a, m, m, e, r, s입니다. 따라서 “programmers”를 return 합니다.입출력 예 #2  예제 2번의 my_string에서 인덱스 0, 1, 2, 3에 해당하는 글자는 각각 z, p, i, a이므로 my_string에서 index_list에 들어있는 원소에 해당하는 인덱스의 글자들은 각각 순서대로 p, i, z, z, a입니다. 따라서 “pizza”를 return 합니다.Solutionimport Foundationfunc solution(_ my_string:String, _ index_list:[Int]) -&gt; String {        let array = Array(my_string)    return index_list.map{ String(array[$0]) }.joined()}"
  },
  
  {
    "title": "Basic37 주사위 게임 3",
    "url": "/posts/ProgrammersBasic-37/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-23 00:00:00 +0900",
    





    
    "snippet": "문제: 주사위 게임 3문제 설명1부터 6까지 숫자가 적힌 주사위가 네 개 있습니다. 네 주사위를 굴렸을 때 나온 숫자에 따라 다음과 같은 점수를 얻습니다.  네 주사위에서 나온 숫자가 모두 p로 같다면 1111 × p점을 얻습니다.  세 주사위에서 나온 숫자가 p로 같고 나머지 다른 주사위에서 나온 숫자가 q(p ≠ q)라면 (10 × p + q)2 ...",
    "content": "문제: 주사위 게임 3문제 설명1부터 6까지 숫자가 적힌 주사위가 네 개 있습니다. 네 주사위를 굴렸을 때 나온 숫자에 따라 다음과 같은 점수를 얻습니다.  네 주사위에서 나온 숫자가 모두 p로 같다면 1111 × p점을 얻습니다.  세 주사위에서 나온 숫자가 p로 같고 나머지 다른 주사위에서 나온 숫자가 q(p ≠ q)라면 (10 × p + q)2 점을 얻습니다.                              주사위가 두 개씩 같은 값이 나오고, 나온 숫자를 각각 p, q(p ≠ q)라고 한다면 (p + q) ×          p - q          점을 얻습니다.                      어느 두 주사위에서 나온 숫자가 p로 같고 나머지 두 주사위에서 나온 숫자가 각각 p와 다른 q, r(q ≠ r)이라면 q × r점을 얻습니다.  네 주사위에 적힌 숫자가 모두 다르다면 나온 숫자 중 가장 작은 숫자 만큼의 점수를 얻습니다.네 주사위를 굴렸을 때 나온 숫자가 정수 매개변수 a, b, c, d로 주어질 때, 얻는 점수를 return 하는 solution 함수를 작성해 주세요.제한사항  a, b, c, d는 1 이상 6 이하의 정수입니다.입출력 예            a      b      c      d      result                  2      2      2      2      2222              4      1      4      4      1681              6      3      3      6      27              2      5      2      6      30              6      4      2      5      2      입출력 예 설명입출력 예 #1  예제 1번에서 네 주사위 숫자가 모두 2로 같으므로 1111 × 2 = 2222점을 얻습니다. 따라서 2222를 return 합니다.입출력 예 #2  예제 2번에서 세 주사위에서 나온 숫자가 4로 같고 나머지 다른 주사위에서 나온 숫자가 1이므로 (10 × 4 + 1)2 = 412 = 1681점을 얻습니다. 따라서 1681을 return 합니다.입출력 예 #3                              예제 3번에서 a, d는 6으로, b, c는 3으로 각각 같으므로 (6 + 3) ×          6 - 3          = 9 × 3 = 27점을 얻습니다. 따라서 27을 return 합니다.                    입출력 예 #4  예제 4번에서 두 주사위에서 2가 나오고 나머지 다른 두 주사위에서 각각 5, 6이 나왔으므로 5 × 6 = 30점을 얻습니다. 따라서 30을 return 합니다.입출력 예 #5  예제 5번에서 네 주사위 숫자가 모두 다르고 나온 숫자 중 가장 작은 숫자가 2이므로 2점을 얻습니다. 따라서 2를 return 합니다.Solution  Array를 만들어 정렬시키고, Set을 만들어줍니다. Set.count를 통해서 중복된 숫자의 경우의 수를 나눌 수 있습니다. case 2의 경우 a,b,c,d중 세개의 숫자가 같은 경우와, 두개씩 같은 경우 두가지가 있습니다. 여기서 세개의 숫자가 같은 경우는 배열을 정렬시켰기 때문에 [2,2,2,5] or [4,6,6,6,]처럼 배열의 0번째와 1번째 값이 다른경우 or 2번째와 3번째가 다른경우로 나뉘어집니다. 이를 제외한 나머지의 경우는 숫자가 두개씩 같은경우가 됩니다.case 3은 두개의 숫자가 같고 나머지는 전부 다른 경우입니다. filter를 사용해서 두개의 값이 같은 원소를 찾아내고(p), 한번 더 필터를 사용해서 p를 제외한 나머지 두개의 요소를 찾아낸 후에, 조건대로 곱해서 return합니다.import Foundationfunc solution(_ a:Int, _ b:Int, _ c:Int, _ d:Int) -&gt; Int {    let array = [a,b,c,d].sorted()    let s = Set(array)    switch s.count {        case 1 :            return 1111 * a        case 2 :            if array[0] != array[1] {                return (10*array[1]+array[0]) * (10*array[1]+array[0])            }            else if array[2] != array[3] {                return (10*array[2]+array[3]) * (10*array[2]+array[3])            }            else {                return (array[1] + array[2]) * abs(array[1] - array[2])            }        case 3 :            let tmp = array.enumerated().filter{index, value in                let nextIndex = index + 1                return nextIndex &lt; array.count &amp;&amp; array[nextIndex] == value            }            let p = tmp.map{$0.element}[0]            let last = s.filter{ $0 != p}                        return last.reduce(1){$0*$1}        case 4 :            return s.min() ?? 0        default :            return -1    }}"
  },
  
  {
    "title": "Basic36 간단한 논리 연산",
    "url": "/posts/ProgrammersBasic-36/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-23 00:00:00 +0900",
    





    
    "snippet": "문제: 간단한 논리 연산문제 설명boolean 변수 x1, x2, x3, x4가 매개변수로 주어질 때, 다음의 식의 true/false를 return 하는 solution 함수를 작성해 주세요.  (x1 ∨ x2) ∧ (x3 ∨ x4)입출력 예            x1      x2      x3      x4      result           ...",
    "content": "문제: 간단한 논리 연산문제 설명boolean 변수 x1, x2, x3, x4가 매개변수로 주어질 때, 다음의 식의 true/false를 return 하는 solution 함수를 작성해 주세요.  (x1 ∨ x2) ∧ (x3 ∨ x4)입출력 예            x1      x2      x3      x4      result                  false      true      true      true      true              true      false      false      false      false      입출력 예 설명입출력 예 #1      예제 1번의 x1, x2, x3, x4로 식을 계산하면 다음과 같습니다.    (x1 ∨ x2) ∧ (x3 ∨ x4) ≡ (F ∨ T) ∧ (T ∨ T) ≡ T ∧ T ≡ T    따라서 true를 return 합니다.  입출력 예 #2      예제 2번의 x1, x2, x3, x4로 식을 계산하면 다음과 같습니다.    (x1 ∨ x2) ∧ (x3 ∨ x4) ≡ (T ∨ F) ∧ (F ∨ F) ≡ T ∧ F ≡ F    따라서 false를 return 합니다.        ∨과 ∧의 진리표는 다음과 같습니다.                            x          y          x ∨ y          x ∧ y                                      T          T          T          T                          T          F          T          F                          F          T          T          F                          F          F          F          F                    Solutionimport Foundationfunc solution(_ x1:Bool, _ x2:Bool, _ x3:Bool, _ x4:Bool) -&gt; Bool {    return (x1 || x2) &amp;&amp; (x3 || x4)}"
  },
  
  {
    "title": "Basic35 배열 만들기 4",
    "url": "/posts/ProgrammersBasic-35/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-22 00:00:00 +0900",
    





    
    "snippet": "문제: 배열 만들기 4문제 설명정수 배열 arr가 주어집니다. arr를 이용해 새로운 배열 stk를 만드려고 합니다.변수 i를 만들어 초기값을 0으로 설정한 후 i가 arr의 길이보다 작으면 다음 작업을 반복합니다.  만약 stk가 빈 배열이라면 arr[i]를 stk에 추가하고 i에 1을 더합니다.  stk에 원소가 있고, stk의 마지막 원소가 ar...",
    "content": "문제: 배열 만들기 4문제 설명정수 배열 arr가 주어집니다. arr를 이용해 새로운 배열 stk를 만드려고 합니다.변수 i를 만들어 초기값을 0으로 설정한 후 i가 arr의 길이보다 작으면 다음 작업을 반복합니다.  만약 stk가 빈 배열이라면 arr[i]를 stk에 추가하고 i에 1을 더합니다.  stk에 원소가 있고, stk의 마지막 원소가 arr[i]보다 작으면 arr[i]를 stk의 뒤에 추가하고 i에 1을 더합니다.  stk에 원소가 있는데 stk의 마지막 원소가 arr[i]보다 크거나 같으면 stk의 마지막 원소를 stk에서 제거합니다.위 작업을 마친 후 만들어진 stk를 return 하는 solution 함수를 완성해 주세요.제한사항  1 ≤ arr의 길이 ≤ 100,000          1 ≤ arr의 원소 ≤ 100,000      입출력 예            arr      result                  [1, 4, 2, 5, 3]      [1, 2, 3]      입출력 예 설명입출력 예 #1  각 작업을 마친 후에 배열의 변화를 나타내면 다음 표와 같습니다.            i      arr[i]      stk                  0      1      []              1      4      [1]              2      2      [1, 4]              2      2      [1]              3      5      [1, 2]              4      3      [1, 2, 5]              4      3      [1, 2]              -      -      [1, 2, 3]        따라서 [1, 2, 3]을 return 합니다.Solutionimport Foundationfunc solution(_ arr:[Int]) -&gt; [Int] {    var stk = [Int]()    var i = 0    while i &lt; arr.count {        if stk.isEmpty {            stk.append(arr[i])            i += 1        }        else if stk.last! &lt; arr[i] {            stk.append(arr[i])            i += 1        }        else {            stk.removeLast()        }    }        return stk}"
  },
  
  {
    "title": "Basic34 콜라츠 수열 만들기",
    "url": "/posts/ProgrammersBasic-34/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-22 00:00:00 +0900",
    





    
    "snippet": "문제: 콜라츠 수열 만들기문제 설명모든 자연수 x에 대해서 현재 값이 x이면 x가 짝수일 때는 2로 나누고, x가 홀수일 때는 3 * x + 1로 바꾸는 계산을 계속해서 반복하면 언젠가는 반드시  x가 1이 되는지 묻는 문제를 콜라츠 문제라고 부릅니다.그리고 위 과정에서 거쳐간 모든 수를 기록한 수열을 콜라츠 수열이라고 부릅니다.계산 결과 1,000 ...",
    "content": "문제: 콜라츠 수열 만들기문제 설명모든 자연수 x에 대해서 현재 값이 x이면 x가 짝수일 때는 2로 나누고, x가 홀수일 때는 3 * x + 1로 바꾸는 계산을 계속해서 반복하면 언젠가는 반드시  x가 1이 되는지 묻는 문제를 콜라츠 문제라고 부릅니다.그리고 위 과정에서 거쳐간 모든 수를 기록한 수열을 콜라츠 수열이라고 부릅니다.계산 결과 1,000 보다 작거나 같은 수에 대해서는 전부 언젠가 1에 도달한다는 것이 알려져 있습니다. 임의의 1,000 보다 작거나 같은 양의 정수 n이 주어질 때 초기값이 n인 콜라츠 수열을 return 하는 solution 함수를 완성해 주세요.제한사항  1 ≤ n ≤ 1,000입출력 예            n      result                  10      [10, 5, 16, 8, 4, 2, 1]      입출력 예 설명입출력 예 #1  순서대로 연산한 결과를 표로 만들면 다음과 같습니다.            연산 횟수      x      홀짝 여부                  0      10      짝수              1      5      홀수              2      16      짝수              3      8      짝수              4      4      짝수              5      2      짝수              6      1      홀수        따라서 [10, 5, 16, 8, 4, 2, 1]을 return 합니다.Solutionimport Foundationfunc solution(_ n:Int) -&gt; [Int] {    var result = [n]    var current = n        while current != 1 {        if current % 2 == 0 {            current = current / 2        }        else {            current = current*3+1        }        result.append(current)    }    return result}"
  },
  
  {
    "title": "Basic33 카운트 업",
    "url": "/posts/ProgrammersBasic-33/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-22 00:00:00 +0900",
    





    
    "snippet": "문제: 카운트 업문제 설명정수 start_num와 end_num가 주어질 때, start_num부터 end_num까지의 숫자를 차례로 담은 리스트를 return하도록 solution 함수를 완성해주세요.제한사항  0 ≤ start_num ≤ end_num ≤ 50입출력 예            start_num      end_num      resul...",
    "content": "문제: 카운트 업문제 설명정수 start_num와 end_num가 주어질 때, start_num부터 end_num까지의 숫자를 차례로 담은 리스트를 return하도록 solution 함수를 완성해주세요.제한사항  0 ≤ start_num ≤ end_num ≤ 50입출력 예            start_num      end_num      result                  3      10      [3, 4, 5, 6, 7, 8, 9, 10]      입출력 예 설명입출력 예 #1  3부터 10까지의 숫자들을 담은 리스트 [3, 4, 5, 6, 7, 8, 9, 10]를 return합니다.Solutionimport Foundationfunc solution(_ start_num:Int, _ end_num:Int) -&gt; [Int] {    return (start_num...end_num).map{$0}}"
  },
  
  {
    "title": "Basic32 배열 만들기 2",
    "url": "/posts/ProgrammersBasic-32/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-20 00:00:00 +0900",
    





    
    "snippet": "문제: 배열 만들기 2문제 설명정수 l과 r이 주어졌을 때, l 이상 r이하의 정수 중에서 숫자 “0”과 “5”로만 이루어진 모든 정수를 오름차순으로 저장한 배열을 return 하는 solution 함수를 완성해 주세요.만약 그러한 정수가 없다면, -1이 담긴 배열을 return 합니다.제한사항  1 ≤ l ≤ r ≤ 1,000,000입출력 예    ...",
    "content": "문제: 배열 만들기 2문제 설명정수 l과 r이 주어졌을 때, l 이상 r이하의 정수 중에서 숫자 “0”과 “5”로만 이루어진 모든 정수를 오름차순으로 저장한 배열을 return 하는 solution 함수를 완성해 주세요.만약 그러한 정수가 없다면, -1이 담긴 배열을 return 합니다.제한사항  1 ≤ l ≤ r ≤ 1,000,000입출력 예            l      r      result                  5      555      [5, 50, 55, 500, 505, 550, 555]              10      20      [-1]      입출력 예 설명입출력 예 #1  5 이상 555 이하의 0과 5로만 이루어진 정수는 작은 수부터 5, 50, 55, 500, 505, 550, 555가 있습니다. 따라서 [5, 50, 55, 500, 505, 550, 555]를 return 합니다.입출력 예 #2  10 이상 20 이하이면서 0과 5로만 이루어진 정수는 없습니다. 따라서 [-1]을 return 합니다.Solution  String으로 변환한 l부터 r까지 숫자를 하나씩 돌면서 \"0\",\"5\"를 제외한 숫자가 포함되어 있지 않을 경우에만 result배열에 추가하는 방식으로 문제를 풀었습니다. 그러나 처음에 테스트케이스 하나에서 시간초과라는 결과가 나왔습니다.import Foundationfunc solution(_ l:Int, _ r:Int) -&gt; [Int] {    let arr = [\"1\",\"2\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\"]    var result = [Int]()        for i in l...r {        let iString = String(i)\t\tif arr.filter{iString.contains($0)}.count == 0 {\t\t\tresult.append(i)\t\t}    }        return result.isEmpty ? [-1] : result}  그래서 if i%5 == 0 를 추가해 줌으로써 i가 5의 배수일 때만 filter를 실행시키도록 하여, 검사 수를 줄여서 시간초과를 해결했습니다.import Foundationfunc solution(_ l:Int, _ r:Int) -&gt; [Int] {    let arr = [\"1\",\"2\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\"]    var result = [Int]()        for i in l...r {        let iString = String(i)        if i%5 == 0 {            if arr.filter{iString.contains($0)}.count == 0 {                result.append(i)            }        }    }        return result.isEmpty ? [-1] : result}  아래 코드는 다른사람이 작성한 효율적인 코드입니다. 먼저, 처음 문제를 풀 때 for문이 아니라 l...r을 이용해 문제를 풀려고 접근했었는데, [l...r]이 코드를 작성하는 실수를 했습니다. [l...r]은 (l...r)과 다르게 ClosedRange로 map을 사용했을때 오류가 발생했습니다.  또한 Set을 사용할 생각은 하지 못했고, isSubset도 알지 못했는데, 이부분을 예시를 들어 해석하자면 \"505\"를 Set으로 변형시켜서 [\"5\",\"0\"]으로 변형하고, isSubset(of:[\"5\",\"0\"])는 앞의 \"505\"의 Set이 (of: )의 Set을 Subset으로 갖는지를 판별해주는 함수입니다.func solution(_ l:Int, _ r:Int) -&gt; [Int] {    let result = (l...r).map{$0}.filter{Set(String($0)).isSubset(of:[\"5\",\"0\"])}    return result.isEmpty ? [-1] : result}"
  },
  
  {
    "title": "Basic31 수열과 구간 쿼리 4",
    "url": "/posts/ProgrammersBasic-31/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-19 00:00:00 +0900",
    





    
    "snippet": "문제: 수열과 구간 쿼리 4문제 설명정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [s, e, k] 꼴입니다.각 query마다 순서대로 s ≤ i ≤ e인 모든 i에 대해 i가 k의 배수이면 arr[i]에 1을 더합니다.위 규칙에 따라 queries를 처리한 이후의 arr를...",
    "content": "문제: 수열과 구간 쿼리 4문제 설명정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [s, e, k] 꼴입니다.각 query마다 순서대로 s ≤ i ≤ e인 모든 i에 대해 i가 k의 배수이면 arr[i]에 1을 더합니다.위 규칙에 따라 queries를 처리한 이후의 arr를 return 하는 solution 함수를 완성해 주세요.제한사항  1 ≤ arr의 길이 ≤ 1,000          0 ≤ arr의 원소 ≤ 1,000,000        1 ≤ queries의 길이 ≤ 1,000          0 ≤ s ≤ e &lt; arr의 길이      0 ≤ k ≤ 5      입출력 예            arr      queries      result                  [0, 1, 2, 4, 3]      [[0, 4, 1],[0, 3, 2],[0, 3, 3]]      [3, 2, 4, 6, 4]      입출력 예 설명입출력 예 #1  각 쿼리에 따라 arr가 다음과 같이 변합니다.            arr                  [0, 1, 2, 4, 3]              [1, 2, 3, 5, 4]              [2, 2, 4, 5, 4]              [3, 2, 4, 6, 4]        따라서 [3, 2, 4, 6, 4]를 return 합니다.Solution  지난번에 공부했던 reduec(into)와 map을 사용해서 문제를 풀어봤습니다.import Foundationfunc solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {    return queries.reduce(into: arr) { result, q in        result = result.enumerated().map{index, value in              index &gt;= q[0] &amp;&amp; index&lt;=q[1] &amp;&amp; index % q[2] == 0 ? value+1 : value        }    }}"
  },
  
  {
    "title": "Basic30 수열과 구간 쿼리 2",
    "url": "/posts/ProgrammersBasic-30/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-18 00:00:00 +0900",
    





    
    "snippet": "문제: 수열과 구간 쿼리 2문제 설명정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [s, e, k] 꼴입니다.각 query마다 순서대로 s ≤ i ≤ e인 모든 i에 대해 k보다 크면서 가장 작은 arr[i]를 찾습니다.각 쿼리의 순서에 맞게 답을 저장한 배열을 반환하는 s...",
    "content": "문제: 수열과 구간 쿼리 2문제 설명정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [s, e, k] 꼴입니다.각 query마다 순서대로 s ≤ i ≤ e인 모든 i에 대해 k보다 크면서 가장 작은 arr[i]를 찾습니다.각 쿼리의 순서에 맞게 답을 저장한 배열을 반환하는 solution 함수를 완성해 주세요.단, 특정 쿼리의 답이 존재하지 않으면 -1을 저장합니다.제한사항  1 ≤ arr의 길이 ≤ 1,000          0 ≤ arr의 원소 ≤ 1,000,000        1 ≤ queries의 길이 ≤ 1,000          0 ≤ s ≤ e &lt; arr의 길이      0 ≤ k ≤ 1,000,000      입출력 예            arr      queries      result                  [0, 1, 2, 4, 3]      [[0, 4, 2],[0, 3, 2],[0, 2, 2]]      [3, 4, -1]      입출력 예 설명입출력 예 #1  첫 번째 쿼리의 범위에는 0, 1, 2, 4, 3이 있으며 이 중 2보다 크면서 가장 작은 값은 3입니다.  두 번째 쿼리의 범위에는 0, 1, 2, 4가 있으며 이 중 2보다 크면서 가장 작은 값은 4입니다.  세 번째 쿼리의 범위에는 0, 1, 2가 있으며 여기에는 2보다 큰 값이 없습니다.  따라서 [3, 4, -1]을 return 합니다.Solutionimport Foundationfunc solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {    var tempArray = [Int]()    var result = [Int]()        for i in 0..&lt;queries.count {        for j in queries[i][0]...queries[i][1] {            if arr[j] &gt; queries[i][2] {                tempArray.append(arr[j])            }        }        tempArray.isEmpty ? result.append(-1) : result.append(tempArray.min() ?? -1)        tempArray = []    }        return result}  map과 filter를 사용해서 코드를 줄인 방법도 있습니다.func solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {    let result = queries.map {        let (s, e, k) = ($0[0], $0[1], $0[2])        return arr[s...e].filter{$0 &gt; k}.min() ?? -1    }    return result}"
  },
  
  {
    "title": "Basic29 수열과 구간 쿼리 3",
    "url": "/posts/ProgrammersBasic-29/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-17 00:00:00 +0900",
    





    
    "snippet": "문제: 수열과 구간 쿼리 3문제 설명정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [i, j] 꼴입니다.각 query마다 순서대로 arr[i]의 값과 arr[j]의 값을 서로 바꿉니다.위 규칙에 따라 queries를 처리한 이후의 arr를 return 하는 solution ...",
    "content": "문제: 수열과 구간 쿼리 3문제 설명정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. queries의 원소는 각각 하나의 query를 나타내며, [i, j] 꼴입니다.각 query마다 순서대로 arr[i]의 값과 arr[j]의 값을 서로 바꿉니다.위 규칙에 따라 queries를 처리한 이후의 arr를 return 하는 solution 함수를 완성해 주세요.제한사항  1 ≤ arr의 길이 ≤ 1,000          0 ≤ arr의 원소 ≤ 1,000,000        1 ≤ queries의 길이 ≤ 1,000          0 ≤ i &lt; j &lt; arr의 길이      입출력 예            arr      queries      result                  [0, 1, 2, 3, 4]      [[0, 3],[1, 2],[1, 4]]      [3, 4, 1, 0, 2]      입출력 예 설명입출력 예 #1  각 쿼리에 따라 arr가 다음과 같이 변합니다.            arr                  [0, 1, 2, 3, 4]              [3, 1, 2, 0, 4]              [3, 2, 1, 0, 4]              [3, 4, 1, 0, 2]        따라서 [3, 4, 1, 0, 2]를 return 합니다.Solution  처음 map을 사용하고, swap로직을 직접 구현해서 문제를 풀었습니다.import Foundationfunc solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {    var array = arr    queries.map {        let tmp = array[$0[0]]        array[$0[0]] = array[$0[1]]        array[$0[1]] = tmp    }        return array}  이후 swapAt 이라는 함수가 있는 것을 알게 되었습니다. swapAt은 swapAt(_ i, _j)의 형태로 사용되고, i, j는 인덱스입니다. 배열안의 각 인덱스의 값을 서로 바꾸어주는 함수입니다.func solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {    var array = arr    queries.map {        array.swapAt($0[0], $0[1])    }    return array}  reduce(into:_:)\u001c를 이용한 풀이도 있습니다. 공식 문서를 보면 reduce(into:_:)는 reduce(::)와 다르게 inout 키워드가 붙은 Result를 받습니다. 따라서 초기값으로 넘기는 인자를 변형하여 결과를 얻고 싶다면, reduce(into:_:)를 사용할 수 있습니다.func solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {    return queries.reduce(into: arr) { result, q in        print(result, q)        result.swapAt(q[0], q[1])    }}"
  },
  
  {
    "title": "Basic28 수 조작하기 2",
    "url": "/posts/ProgrammersBasic-28/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-16 00:00:00 +0900",
    





    
    "snippet": "문제: 수 조작하기 2문제 설명정수 배열 numLog가 주어집니다. 처음에 numLog[0]에서 부터 시작해 “w”, “a”, “s”, “d”로 이루어진 문자열을 입력으로 받아 순서대로 다음과 같은 조작을 했다고 합시다.  “w” : 수에 1을 더한다.  ”s” : 수에 1을 뺀다.  “d” : 수에 10을 더한다.  “a” : 수에 10을 뺀다.그리...",
    "content": "문제: 수 조작하기 2문제 설명정수 배열 numLog가 주어집니다. 처음에 numLog[0]에서 부터 시작해 “w”, “a”, “s”, “d”로 이루어진 문자열을 입력으로 받아 순서대로 다음과 같은 조작을 했다고 합시다.  “w” : 수에 1을 더한다.  ”s” : 수에 1을 뺀다.  “d” : 수에 10을 더한다.  “a” : 수에 10을 뺀다.그리고 매번 조작을 할 때마다 결괏값을 기록한 정수 배열이 numLog입니다. 즉, numLog[i]는 numLog[0]로부터 총 i번의 조작을 가한 결과가 저장되어 있습니다.주어진 정수 배열 numLog에 대해 조작을 위해 입력받은 문자열을 return 하는 solution 함수를 완성해 주세요.제한사항  2 ≤ numLog의 길이 ≤ 100,000          -100,000 ≤ numLog[0] ≤ 100,000      1 ≤ i ≤ numLog의 길이인 모든 i에 대해 |numLog[i] - numLog[i - 1]|의 값은 1 또는 10입니다.      입출력 예            numLog      result                  [0, 1, 0, 10, 0, 1, 0, 10, 0, -1, -2, -1]      “wsdawsdassw”      입출력 예 설명입출력 예 #1  result인 “wsdawsdassw”를 따라 numLog[0]에서부터 시작해 조작을 하면 numLog의 값과 순서대로 일치합니다. 따라서 “wsdawsdassw”를 return 합니다.Hint“수 조작하기 1” 문제의 n값이 numLog[0]에 해당하며, 이 문제에서 주어진 numLog에 따라 “수 조작하기 1” 문제의 control을 구하는 문제라고 이해할 수 있습니다.입출력 예 #1은 “수 조작하기 1” 문제의 입출력 예 #1과 같은 예시이므로 참고하시기 바랍니다.Solution  switch case를 이용해 문제를 풀었습니다.import Foundationfunc solution(_ numLog:[Int]) -&gt; String {    var result = \"\"    for i in 0..&lt;numLog.count-1 {        switch numLog[i+1] - numLog[i] {            case 1:                result += \"w\"                break            case -1:                result += \"s\"                break            case 10:                result += \"d\"                break            case -10:                result += \"a\"                break            default :                break        }    }    return result}"
  },
  
  {
    "title": "Basic27 수 조작하기 1",
    "url": "/posts/ProgrammersBasic-27/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-16 00:00:00 +0900",
    





    
    "snippet": "문제: 수 조작하기 1문제 설명정수 n과 문자열 control이 주어집니다. control은 “w”, “a”, “s”, “d”의 4개의 문자로 이루어져 있으며, control의 앞에서부터 순서대로 문자에 따라 n의 값을 바꿉니다.  “w” : n이 1 커집니다.  ”s” : n이 1 작아집니다.  “d” : n이 10 커집니다.  “a” : n이 10...",
    "content": "문제: 수 조작하기 1문제 설명정수 n과 문자열 control이 주어집니다. control은 “w”, “a”, “s”, “d”의 4개의 문자로 이루어져 있으며, control의 앞에서부터 순서대로 문자에 따라 n의 값을 바꿉니다.  “w” : n이 1 커집니다.  ”s” : n이 1 작아집니다.  “d” : n이 10 커집니다.  “a” : n이 10 작아집니다.위 규칙에 따라 n을 바꿨을 때 가장 마지막에 나오는 n의 값을 return 하는 solution 함수를 완성해 주세요.제한사항  -100,000 ≤ n ≤ 100,000  1 ≤ control의 길이 ≤ 100,000          control은 알파벳 소문자 “w”, “a”, “s”, “d”로 이루어진 문자열입니다.      입출력 예            n      control      result                  0      “wsdawsdassw”      -1      입출력 예 설명입출력 예 #1  수 n은 control에 따라 다음과 같은 순서로 변하게 됩니다.  0 → 1 → 0 → 10 → 0 → 1 → 0 → 10 → 0 → -1 → -2 → -1  따라서 -1을 return 합니다.Solution  switch case를 사용해서 문제를 풀었습니다.import Foundationfunc solution(_ n:Int, _ control:String) -&gt; Int {    var result = n    let controllArray = Array(control)        for sign in controllArray {        switch sign {            case \"w\":                 result += 1                break            case \"s\":                 result -= 1                break            case \"d\":                 result += 10                break            case \"a\":                 result -= 10                break            default:                 break        }    }        return result}"
  },
  
  {
    "title": "Basic26 마지막 두 원소",
    "url": "/posts/ProgrammersBasic-26/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-15 00:00:00 +0900",
    





    
    "snippet": "문제: 마지막 두 원소문제 설명정수 리스트 num_list가 주어질 때, 마지막 원소가 그전 원소보다 크면 마지막 원소에서 그전 원소를 뺀 값을 마지막 원소가 그전 원소보다 크지 않다면 마지막 원소를 두 배한 값을 추가하여 return하도록 solution 함수를 완성해주세요.제한사항  2 ≤ num_list의 길이 ≤ 10  1 ≤ num_list의...",
    "content": "문제: 마지막 두 원소문제 설명정수 리스트 num_list가 주어질 때, 마지막 원소가 그전 원소보다 크면 마지막 원소에서 그전 원소를 뺀 값을 마지막 원소가 그전 원소보다 크지 않다면 마지막 원소를 두 배한 값을 추가하여 return하도록 solution 함수를 완성해주세요.제한사항  2 ≤ num_list의 길이 ≤ 10  1 ≤ num_list의 원소 ≤ 9입출력 예            num_list      result                  [2, 1, 6]      [2, 1, 6, 5]              [5, 2, 1, 7, 5]      [5, 2, 1, 7, 5, 10]      입출력 예 설명입출력 예 #1  마지막 원소인 6이 그전 원소인 1보다 크기 때문에 6 - 1인 5를 추가해 return합니다.입출력 예 #2  마지막 원소인 5가 그전 원소인 7보다 크지 않기 때문에 5의 두 배인 10을 추가해 return합니다.Solutionimport Foundationfunc solution(_ num_list:[Int]) -&gt; [Int] {    var result = num_list    let lastElement = num_list[num_list.count - 1]    let beforeLastElement = num_list[num_list.count - 2]        result.append(lastElement &gt; beforeLastElement ? lastElement - beforeLastElement : lastElement * 2)    return result}"
  },
  
  {
    "title": "Basic25 이어 붙인 수",
    "url": "/posts/ProgrammersBasic-25/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-15 00:00:00 +0900",
    





    
    "snippet": "문제: 이어 붙인 수문제 설명정수가 담긴 리스트 num_list가 주어집니다. num_list의 홀수만 순서대로 이어 붙인 수와 짝수만 순서대로 이어 붙인 수의 합을 return하도록 solution 함수를 완성해주세요.제한사항  2 ≤ num_list의 길이 ≤ 10  1 ≤ num_list의 원소 ≤ 9  num_list에는 적어도 한 개씩의 짝수...",
    "content": "문제: 이어 붙인 수문제 설명정수가 담긴 리스트 num_list가 주어집니다. num_list의 홀수만 순서대로 이어 붙인 수와 짝수만 순서대로 이어 붙인 수의 합을 return하도록 solution 함수를 완성해주세요.제한사항  2 ≤ num_list의 길이 ≤ 10  1 ≤ num_list의 원소 ≤ 9  num_list에는 적어도 한 개씩의 짝수와 홀수가 있습니다.입출력 예            num_list      result                  [3, 4, 5, 2, 1]      393              [5, 7, 8, 3]      581      입출력 예 설명입출력 예 #1  홀수만 이어 붙인 수는 351이고 짝수만 이어 붙인 수는 42입니다. 두 수의 합은 393입니다.입출력 예 #2  홀수만 이어 붙인 수는 573이고 짝수만 이어 붙인 수는 8입니다. 두 수의 합은 581입니다.Solution  filter와 reduce 함수를 이용해서 문제를 풀었습니다.import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {    let odd = Int(num_list.filter{$0 % 2 != 0}.reduce(\"\"){String($0) + String($1)}) ?? 0    let even = Int(num_list.filter{$0 % 2 == 0}.reduce(\"\"){String($0) + String($1)}) ?? 0        return odd + even}  아래는 같은 방법이지만 조금 더 깔끔한 코드입니다. filter, map, joined을 사용했습니다.func solution(_ num_list:[Int]) -&gt; Int {    let odd = Int(num_list.filter{$0 % 2 != 0}.map{String($0)}.joined()) ?? 0    let even = Int(num_list.filter{$0 % 2 == 0}.map{String($0)}.joined()) ?? 0        return odd + even}"
  },
  
  {
    "title": "Basic24 원소들의 곱과 합",
    "url": "/posts/ProgrammersBasic-24/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-15 00:00:00 +0900",
    





    
    "snippet": "문제: 원소들의 곱과 합문제 설명정수가 담긴 리스트 num_list가 주어질 때, 모든 원소들의 곱이 모든 원소들의 합의 제곱보다 작으면 1을 크면 0을 return하도록 solution 함수를 완성해주세요.제한사항  2 ≤ num_list의 길이 ≤ 10  1 ≤ num_list의 원소 ≤ 9입출력 예            num_list      r...",
    "content": "문제: 원소들의 곱과 합문제 설명정수가 담긴 리스트 num_list가 주어질 때, 모든 원소들의 곱이 모든 원소들의 합의 제곱보다 작으면 1을 크면 0을 return하도록 solution 함수를 완성해주세요.제한사항  2 ≤ num_list의 길이 ≤ 10  1 ≤ num_list의 원소 ≤ 9입출력 예            num_list      result                  [3, 4, 5, 2, 1]      1              [5, 7, 8, 3]      0      입출력 예 설명입출력 예 #1  모든 원소의 곱은 120, 합의 제곱은 225이므로 1을 return합니다.입출력 예 #2  모든 원소의 곱은 840, 합의 제곱은 529이므로 0을 return합니다.Solution  reduce함수를 사용해 문제를 해결했습니다. 여기서 reduce(0)의 ()안에 들어가는 매개변수는 initialResult로 초기누적값을 의미하는데, 이는 1부터 5를 더할때 initialResult + 1로 시작한다는 의미입니다. 그래서 처음에 *에도 reduce(0)을 사용했었는데, 이 때 초기값이 0*1이 되면서 모든 결과값이 0이 되는 상황을 겪었습니다.import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {    let multiplication = num_list.reduce(1){$0 * $1}    let sumSquar = pow(Float(num_list.reduce(0){$0 + $1}), 2)    return multiplication &lt; Int(sumSquar) ? 1 : 0}  또한 reduce는 아래처럼 reduce(0, +)이렇게 사용할 수도 있습니다.func solution(_ num_list:[Int]) -&gt; Int {    let multiplication = num_list.reduce(1, *)    let sumSquar = pow(Float(num_list.reduce(0, +), 2)    return multiplication &lt; Int(sumSquar) ? 1 : 0}"
  },
  
  {
    "title": "Basic23 주사위 게임 2",
    "url": "/posts/ProgrammersBasic-23/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-15 00:00:00 +0900",
    





    
    "snippet": "문제: 주사위 게임 2문제 설명1부터 6까지 숫자가 적힌 주사위가 세 개 있습니다. 세 주사위를 굴렸을 때 나온 숫자를 각각 a, b, c라고 했을 때 얻는 점수는 다음과 같습니다.  세 숫자가 모두 다르다면 a + b + c 점을 얻습니다.  세 숫자 중 어느 두 숫자는 같고 나머지 다른 숫자는 다르다면 (a + b + c) × (a2 + b2 + ...",
    "content": "문제: 주사위 게임 2문제 설명1부터 6까지 숫자가 적힌 주사위가 세 개 있습니다. 세 주사위를 굴렸을 때 나온 숫자를 각각 a, b, c라고 했을 때 얻는 점수는 다음과 같습니다.  세 숫자가 모두 다르다면 a + b + c 점을 얻습니다.  세 숫자 중 어느 두 숫자는 같고 나머지 다른 숫자는 다르다면 (a + b + c) × (a2 + b2 + c2 )점을 얻습니다.  세 숫자가 모두 같다면 (a + b + c) × (a2 + b2 + c2 ) × (a3 + b3 + c3 )점을 얻습니다.세 정수 a, b, c가 매개변수로 주어질 때, 얻는 점수를 return 하는 solution 함수를 작성해 주세요.제한사항  a, b, c는 1이상 6이하의 정수입니다.입출력 예            a      b      c      result                  2      6      1      9              5      3      3      473              4      4      4      110592      입출력 예 설명입출력 예 #1  예제 1번에서 세 주사위 숫자가 모두 다르므로 2 + 6 + 1 = 9점을 얻습니다. 따라서 9를 return 합니다.입출력 예 #2  예제 2번에서 두 주사위 숫자만 같으므로 (5 + 3 + 3) × (52 + 32 + 32 ) = 11 × 43 = 473점을 얻습니다. 따라서 473을 return 합니다.입출력 예 #3  예제 3번에서 세 주사위 숫자가 모두 같으므로 (4 + 4 + 4) × (42 + 42 + 42 ) × (43 + 43 + 43 ) = 12 × 48 × 192 = 110,592점을 얻습니다. 따라서 110592를 return 합니다.Solution  switch case문을 사용하여 세 개의 숫자가 다 같은 경우, 다 다른 경우 , 나머지로 나누었습니다. 또한 n제곱은 a*a*a이런 방식으로도 가능하며, pow(a, 3)함수를 사용할 수 있습니다.import Foundationfunc solution(_ a:Int, _ b:Int, _ c:Int) -&gt; Int {    switch (true) {        case a == b &amp;&amp; b == c :            return Int(27 * pow(Float(a), 6)) //(3*a)*(3*a*a)*(3*a*a*a)         case a != b &amp;&amp; b != c &amp;&amp; a != c :            return a + b + c        default:            return (a + b + c) * (a*a + b*b + c*c)    }}"
  },
  
  {
    "title": "Basic22 등차수열의 특정한 항만 더하기",
    "url": "/posts/ProgrammersBasic-22/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-15 00:00:00 +0900",
    





    
    "snippet": "문제: 등차수열의 특정한 항만 더하기문제 설명두 정수 a, d와 길이가 n인 boolean 배열 included가 주어집니다. 첫째항이 a, 공차가 d인 등차수열에서 included[i]가 i + 1항을 의미할 때, 이 등차수열의 1항부터 n항까지 included가 true인 항들만 더한 값을 return 하는 solution 함수를 작성해 주세요.제...",
    "content": "문제: 등차수열의 특정한 항만 더하기문제 설명두 정수 a, d와 길이가 n인 boolean 배열 included가 주어집니다. 첫째항이 a, 공차가 d인 등차수열에서 included[i]가 i + 1항을 의미할 때, 이 등차수열의 1항부터 n항까지 included가 true인 항들만 더한 값을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ a ≤ 100  1 ≤ d ≤ 100  1 ≤ included의 길이 ≤ 100  included에는 true가 적어도 하나 존재합니다.입출력 예            a      d      included      result                  3      4      [true, false, false, true, true]      37              7      1      [false, false, false, true, false, false, false]      10      입출력 예 설명입출력 예 #1      예제 1번은 a와 d가 각각 3, 4이고 included의 길이가 5입니다. 이를 표로 나타내면 다음과 같습니다.                                       1항          2항          3항          4항          5항                                      등차수열          3          7          11          15          19                          included          true          false          false          true          true                      따라서 true에 해당하는 1항, 4항, 5항을 더한 3 + 15 + 19 = 37을 return 합니다.  입출력 예 #2      예제 2번은 a와 d가 각각 7, 1이고 included의 길이가 7입니다. 이를 표로 나타내면 다음과 같습니다.                                       1항          2항          3항          4항          5항          6항          7항                                      등차수열          7          8          9          10          11          12          13                          included          false          false          false          true          false          false          false                      따라서 4항만 true이므로 10을 return 합니다.  Solution  for문을 이용해 풀었습니다.import Foundationfunc solution(_ a:Int, _ d:Int, _ included:[Bool]) -&gt; Int {    var result = 0    for i in 0..&lt;included.count {        if included[i] {            result += a + d*i        }    }    return result}"
  },
  
  {
    "title": "Basic21 코드 처리하기",
    "url": "/posts/ProgrammersBasic-21/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-14 00:00:00 +0900",
    





    
    "snippet": "문제: 코드 처리하기문제 설명문자열 code가 주어집니다.code를 앞에서부터 읽으면서 만약 문자가 “1”이면 mode를 바꿉니다. mode에 따라 code를 읽어가면서 문자열 ret을 만들어냅니다.mode는 0과 1이 있으며, idx를 0 부터 code의 길이 - 1 까지 1씩 키워나가면서 code[idx]의 값에 따라 다음과 같이 행동합니다.  m...",
    "content": "문제: 코드 처리하기문제 설명문자열 code가 주어집니다.code를 앞에서부터 읽으면서 만약 문자가 “1”이면 mode를 바꿉니다. mode에 따라 code를 읽어가면서 문자열 ret을 만들어냅니다.mode는 0과 1이 있으며, idx를 0 부터 code의 길이 - 1 까지 1씩 키워나가면서 code[idx]의 값에 따라 다음과 같이 행동합니다.  mode가 0일 때           code[idx]가 “1”이 아니면 idx가 짝수일 때만 ret의 맨 뒤에 code[idx]를 추가합니다.      code[idx]가 “1”이면 mode를 0에서 1로 바꿉니다.        mode가 1일 때          code[idx]가 “1”이 아니면 idx가 홀수일 때만 ret의 맨 뒤에 code[idx]를 추가합니다.      code[idx]가 “1”이면 mode를 1에서 0으로 바꿉니다.      문자열 code를 통해 만들어진 문자열 ret를 return 하는 solution 함수를 완성해 주세요.단, 시작할 때 mode는 0이며, return 하려는 ret가 만약 빈 문자열이라면 대신 “EMPTY”를 return 합니다.제한사항  1 ≤ code의 길이 ≤ 100,000          code는 알파벳 소문자 또는 “1”로 이루어진 문자열입니다.      입출력 예            code      result                  “abc1abc1abc”      “acbac”      입출력 예 설명입출력 예 #1  code의 각 인덱스 i에 따라 다음과 같이 mode와 ret가 변합니다.            i      code[i]      mode      ret                  0      “a”      0      “a”              1      “b”      0      “a”              2      “c”      0      “ac”              3      “1”      1      “ac”              4      “a”      1      “ac”              5      “b”      1      “acb”              6      “c”      1      “acb”              7      “1”      0      “acb”              8      “a”      0      “acba”              9      “b”      0      “acba”              10      “c”      0      “acbac”      따라서 “acbac”를 return 합니다.Solution  문제의 조건에 따라 for문과 if문을 이용해 풀은 코드는 아래와 같습니다.import Foundationfunc solution(_ code:String) -&gt; String {    var mode = 0    var codeArray = Array(code)    var ret = [Character]()    for i in 0..&lt;code.count {        if mode == 0 {            if codeArray[i] == \"1\" {                mode = 1                continue;            }            if i % 2 == 0 {                ret.append(codeArray[i])            }        }         else {            if codeArray[i] == \"1\" {                mode = 0                continue;            }                        if i % 2 != 0 {                ret.append(codeArray[i])            }        }        }    return String(ret) == \"\" ? \"EMPTY\" : String(ret)}  이후 다른 풀이법으로, enumerated()함수를 사용해 코드를 줄일 수 있었습니다.func solution(_ code:String) -&gt; String {\tvar mode = false\tvar ret = \"\"\tcode.enumerated().forEach{ index, char in\t\tif char == \"1\"{mode.toggle()}\t\telse {\t\t\tif !mode &amp;&amp; index % 2 == 0 {\t\t\t\tret += String(char)\t\t\t}\t\t\telse if mode &amp;&amp; index % 2 != 0 {\t\t\t\tret += String(char)\t\t\t}\t\t}    }        return ret.isEmpty ? \"EMPTY\" : ret}"
  },
  
  {
    "title": "Basic20 flag에 따라 다른 값 반환하기",
    "url": "/posts/ProgrammersBasic-20/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-14 00:00:00 +0900",
    





    
    "snippet": "문제: flag에 따라 다른 값 반환하기문제 설명두 정수 a, b와 boolean 변수 flag가 매개변수로 주어질 때, flag가 true면 a + b를 false면 a - b를 return 하는 solution 함수를 작성해 주세요.제한사항  -1,000 ≤ a, b ≤ 1,000입출력 예            a      b      flag   ...",
    "content": "문제: flag에 따라 다른 값 반환하기문제 설명두 정수 a, b와 boolean 변수 flag가 매개변수로 주어질 때, flag가 true면 a + b를 false면 a - b를 return 하는 solution 함수를 작성해 주세요.제한사항  -1,000 ≤ a, b ≤ 1,000입출력 예            a      b      flag      result                  -4      7      true      3              -4      7      false      -11      입출력 예입출력 예 #1  예제 1번에서 flag가 true이므로 a + b = (-4) + 7 = 3을 return 합니다.입출력 예 #2  예제 2번에서 flag가 false이므로 a - b = (-4) - 7 = -11을 return 합니다.Solution  3항 연산자를 이용했습니다.import Foundationfunc solution(_ a:Int, _ b:Int, _ flag:Bool) -&gt; Int {    return flag ? a + b : a - b}"
  },
  
  {
    "title": "Basic19 조건 문자열",
    "url": "/posts/ProgrammersBasic-19/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-14 00:00:00 +0900",
    





    
    "snippet": "문제: 조건 문자열문제 설명문자열에 따라 다음과 같이 두 수의 크기를 비교하려고 합니다.   두 수가 n과 m이라면          ”&gt;”, “=” : n &gt;= m      ”&lt;”, “=” : n &lt;= m      ”&gt;”, “!” : n &gt; m      ”&lt;”, “!” : n &lt; m      두 문자열 ine...",
    "content": "문제: 조건 문자열문제 설명문자열에 따라 다음과 같이 두 수의 크기를 비교하려고 합니다.   두 수가 n과 m이라면          ”&gt;”, “=” : n &gt;= m      ”&lt;”, “=” : n &lt;= m      ”&gt;”, “!” : n &gt; m      ”&lt;”, “!” : n &lt; m      두 문자열 ineq와 eq가 주어집니다. ineq는 “&lt;”와 “&gt;”중 하나고, eq는 “=”와 “!”중 하나입니다. 그리고 두 정수 n과 m이 주어질 때, n과 m이 ineq와 eq의 조건에 맞으면 1을 아니면 0을 return하도록 solution 함수를 완성해주세요.제한 사항  1 ≤ n, m ≤ 100입출력 예            ineq      eq      n      m      result                  ”&lt;”      ”=”      20      50      1              ”&gt;”      ”!”      41      78      0      입출력 예 설명입출력 예 #1  20 &lt;= 50은 참이기 때문에 1을 return합니다.입출력 예 #2  41 &gt; 78은 거짓이기 때문에 0을 return합니다.Solution  switch case문을 사용하여 문제를 해결했습니다.import Foundationfunc solution(_ ineq:String, _ eq:String, _ n:Int, _ m:Int) -&gt; Int {    switch (ineq, eq){        case (\"&gt;\", \"=\") :            return n &gt;= m ? 1 : 0        case (\"&lt;\", \"=\") :            return n &lt;= m ? 1 : 0        case (\"&gt;\", \"!\") :            return n &gt; m ? 1 : 0        case (\"&lt;\", \"!\") :            return n &lt; m ? 1 : 0        default :            return n == m ? 1 : 0    }}"
  },
  
  {
    "title": "Basic18 홀짝에 따라 다른 값 반환하기",
    "url": "/posts/ProgrammersBasic-18/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-14 00:00:00 +0900",
    





    
    "snippet": "문제: 홀짝에 따라 다른 값 반환하기문제 설명양의 정수 n이 매개변수로 주어질 때, n이 홀수라면 n 이하의 홀수인 모든 양의 정수의 합을 return 하고 n이 짝수라면 n 이하의 짝수인 모든 양의 정수의 제곱의 합을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ n ≤ 100입출력 예            n      re...",
    "content": "문제: 홀짝에 따라 다른 값 반환하기문제 설명양의 정수 n이 매개변수로 주어질 때, n이 홀수라면 n 이하의 홀수인 모든 양의 정수의 합을 return 하고 n이 짝수라면 n 이하의 짝수인 모든 양의 정수의 제곱의 합을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ n ≤ 100입출력 예            n      result                  7      16              10      220      입출력 예 설명입출력 예 #1  예제 1번의 n은 7로 홀수입니다. 7 이하의 모든 양의 홀수는 1, 3, 5, 7이고 이들의 합인 1 + 3 + 5 + 7 = 16을 return 합니다.입출력 예 #2  예제 2번의 n은 10으로 짝수입니다. 10 이하의 모든 양의 짝수는 2, 4, 6, 8, 10이고 이들의 제곱의 합인 22 + 42 + 62 + 82 + 102 = 4 + 16 + 36 + 64 + 100 = 220을 return 합니다.Solution  처음에 적당한 문법이 떠오르지 않아서 for문, %연산자를 통해 문제를 해결했습니다.import Foundationfunc solution(_ n:Int) -&gt; Int {    var result = 0        if n % 2 == 0 {        for i in 0...n {            if i % 2 == 0 {                result += (i*i)            }        }    } else {        for i in 0...n {            if i % 2 != 0 {                result += i            }        }    }    return result}  이후 stride라는 함수를 알게되어서 적용시켜 보았습니다. stride(from: x, through: y, by: z)는 x부터 y까지(through는 y포함 to는 y포함하지 않음) z의 보폭으로 나아간다고 생각하면 이해하기 좋습니다.func solution(_ n:Int) -&gt; Int {    if n % 2 != 0 {        return stride(from: 1, through: n, by: 2).reduce(0){$0 + $1}    } else {        return stride(from: 2, through: n, by: 2).reduce(0){$0 + $1 * $1}    }}"
  },
  
  {
    "title": "Basic17 공배수",
    "url": "/posts/ProgrammersBasic-17/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-13 00:00:00 +0900",
    





    
    "snippet": "문제: 공배수문제 설명정수 number와 n, m이 주어집니다. number가 n의 배수이면서 m의 배수이면 1을 아니라면 0을 return하도록 solution 함수를 완성해주세요.제한사항  10 ≤ number ≤ 100  2 ≤ n, m &lt; 10입출력 예            number      n      m      result     ...",
    "content": "문제: 공배수문제 설명정수 number와 n, m이 주어집니다. number가 n의 배수이면서 m의 배수이면 1을 아니라면 0을 return하도록 solution 함수를 완성해주세요.제한사항  10 ≤ number ≤ 100  2 ≤ n, m &lt; 10입출력 예            number      n      m      result                  60      2      3      1              55      10      5      0      입출력 예 설명입출력 예 #1  60은 2의 배수이면서 3의 배수이기 때문에 1을 return합니다.입출력 예 #2  55는 5의 배수이지만 10의 배수가 아니기 때문에 0을 return합니다.Solution  이전 문제와 마찬가지로 %연산을 통해 문제를 해결했습니다. 공배수이기 때문에 number가 n, m둘 다의 배수인 경우만을 1로 반환하게 합니다.import Foundationfunc solution(_ number:Int, _ n:Int, _ m:Int) -&gt; Int {        return (number % n == 0 &amp;&amp; number % m == 0) ? 1 : 0}"
  },
  
  {
    "title": "Basic16 n의 배수",
    "url": "/posts/ProgrammersBasic-16/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-13 00:00:00 +0900",
    





    
    "snippet": "문제: n의 배수문제 설명정수 num과 n이 매개 변수로 주어질 때, num이 n의 배수이면 1을 return n의 배수가 아니라면 0을 return하도록 solution 함수를 완성해주세요.제한사항  2 ≤ num ≤ 100  2 ≤ n ≤ 9입출력 예            num      n      result                  98 ...",
    "content": "문제: n의 배수문제 설명정수 num과 n이 매개 변수로 주어질 때, num이 n의 배수이면 1을 return n의 배수가 아니라면 0을 return하도록 solution 함수를 완성해주세요.제한사항  2 ≤ num ≤ 100  2 ≤ n ≤ 9입출력 예            num      n      result                  98      2      1              34      3      0      입출력 예 설명입출력 예 #1  98은 2의 배수이므로 1을 return합니다.입출력 예 #2  32는 3의 배수가 아니므로 0을 return합니다.Solution  num이 n의 배수라면 num / 2의 나머지는 0이 됩니다. 따라서 나머지 연산자 % 를 사용하여 문제를 풀었습니다.import Foundationfunc solution(_ num:Int, _ n:Int) -&gt; Int {    return num % n == 0 ? 1 : 0}"
  },
  
  {
    "title": "Basic15 두 수의 연산값 비교하기",
    "url": "/posts/ProgrammersBasic-15/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-13 00:00:00 +0900",
    





    
    "snippet": "문제: 두 수의 연산값 비교하기문제 설명연산 ⊕는 두 정수에 대한 연산으로 두 정수를 붙여서 쓴 값을 반환합니다. 예를 들면 다음과 같습니다.  12 ⊕ 3 = 123  3 ⊕ 12 = 312양의 정수 a와 b가 주어졌을 때, a ⊕ b와 2 * a * b 중 더 큰 값을 return하는 solution 함수를 완성해 주세요.단, a ⊕ b와 2 * ...",
    "content": "문제: 두 수의 연산값 비교하기문제 설명연산 ⊕는 두 정수에 대한 연산으로 두 정수를 붙여서 쓴 값을 반환합니다. 예를 들면 다음과 같습니다.  12 ⊕ 3 = 123  3 ⊕ 12 = 312양의 정수 a와 b가 주어졌을 때, a ⊕ b와 2 * a * b 중 더 큰 값을 return하는 solution 함수를 완성해 주세요.단, a ⊕ b와 2 * a * b가 같으면  a ⊕ b를 return 합니다.제한사항  1 ≤ a, b &lt; 10,000입출력 예            a      b      result                  2      91      364              91      2      912      입출력 예 설명입출력 예 #1  a ⊕ b = 291 이고, 2 * a * b = 364 입니다. 둘 중 더 큰 값은 364 이므로 364를 return 합니다.입출력 예 #2  a ⊕ b = 912 이고, 2 * a * b = 364 입니다. 둘 중 더 큰 값은 912 이므로 912를 return 합니다.Solution  a ⊕ b의 연산은 String 형변환과 String의 덧셈연산을 통해 구하고, 2 * a * b의 연산은 그대로 Int의 연산으로 구한 후, 값을 비교했습니다.import Foundationfunc solution(_ a:Int, _ b:Int) -&gt; Int {    let result1 = Int(String(a) + String(b)) ?? 0    let result2 = 2 * a * b        return (result1 &gt;= result2 ? result1 : result2)}"
  },
  
  {
    "title": "Basic14 더 크게 합치기",
    "url": "/posts/ProgrammersBasic-14/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-13 00:00:00 +0900",
    





    
    "snippet": "14. 더 크게 합치기문제 설명연산 ⊕는 두 정수에 대한 연산으로 두 정수를 붙여서 쓴 값을 반환합니다. 예를 들면 다음과 같습니다.  12 ⊕ 3 = 123  3 ⊕ 12 = 312양의 정수 a와 b가 주어졌을 때, a ⊕ b와 b ⊕ a 중 더 큰 값을 return 하는 solution 함수를 완성해 주세요.단, a ⊕ b와 b ⊕ a가 같다면 a...",
    "content": "14. 더 크게 합치기문제 설명연산 ⊕는 두 정수에 대한 연산으로 두 정수를 붙여서 쓴 값을 반환합니다. 예를 들면 다음과 같습니다.  12 ⊕ 3 = 123  3 ⊕ 12 = 312양의 정수 a와 b가 주어졌을 때, a ⊕ b와 b ⊕ a 중 더 큰 값을 return 하는 solution 함수를 완성해 주세요.단, a ⊕ b와 b ⊕ a가 같다면 a ⊕ b를 return 합니다.제한사항  1 ≤ a, b &lt; 10,000입출력 예            a      b      result                  9      91      991              89      8      898      입출력 예 설명입출력 예 #1  a ⊕ b = 991 이고, b ⊕ a = 919 입니다. 둘 중 더 큰 값은 991 이므로 991을 return 합니다.입출력 예 #2  a ⊕ b = 898 이고, b ⊕ a = 889 입니다. 둘 중 더 큰 값은 898 이므로 898을 return 합니다.Solution  String으로 형변환을 통해서 a와b를 붙이고, 다시 Int로 형변환을 통해 두개의 결과 값을 비교하여 더 큰 값을 return 했습니다.import Foundationfunc solution(_ a:Int, _ b:Int) -&gt; Int {    let str1 = String(a) + String(b)    let str2 = String(b) + String(a)    let result1 = Int(str1) ?? 0    let result2 = Int(str2) ?? 0        return (result1 &gt; result2 ? result1 : result2)}"
  },
  
  {
    "title": "Basic13 문자열 곱하기",
    "url": "/posts/ProgrammersBasic-13/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-13 00:00:00 +0900",
    





    
    "snippet": "13. 문자열 곱하기문제 설명문자열 my_string과 정수 k가 주어질 때, my_string을 k번 반복한 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ my_string의 길이 ≤ 100  my_string은 영소문자로만 이루어져 있습니다.  1 ≤ k ≤ 100입출력 예            my_string ...",
    "content": "13. 문자열 곱하기문제 설명문자열 my_string과 정수 k가 주어질 때, my_string을 k번 반복한 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  1 ≤ my_string의 길이 ≤ 100  my_string은 영소문자로만 이루어져 있습니다.  1 ≤ k ≤ 100입출력 예            my_string      k      result                  “string”      3      “stringstringstring”              “love”      10      “lovelovelovelovelovelovelovelovelovelove”      입출력 예 설명입출력 예 #1  예제 1번의 my_string은 “string”이고 이를 3번 반복한 문자열은 “stringstringstring”이므로 이를 return 합니다.입출력 예 #2  예제 2번의 my_string은 “love”이고 이를 10번 반복한 문자열은 “lovelovelovelovelovelovelovelovelovelove”이므로 이를 return 합니다.Solution  간단하게 반복문으로도 구현할 수 있겠지만 String의 init 중 (repeating:count:)를 사용해서 구현할 수 있습니다.import Foundationfunc solution(_ my_string:String, _ k:Int) -&gt; String {    return String(repeating: my_string, count: k)}"
  },
  
  {
    "title": "Basic12 문자 리스트를 문자열로 변환하기",
    "url": "/posts/ProgrammersBasic-12/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-12 00:00:00 +0900",
    





    
    "snippet": "12. 문자 리스트를 문자열로 변환하기문제 설명문자들이 담겨있는 배열 arr가 주어집니다. arr의 원소들을 순서대로 이어 붙인 문자열을 return 하는 solution함수를 작성해 주세요.제한사항  1 ≤ arr의 길이 ≤ 200          arr의 원소는 전부 알파벳 소문자로 이루어진 길이가 1인 문자열입니다.      입출력 예      ...",
    "content": "12. 문자 리스트를 문자열로 변환하기문제 설명문자들이 담겨있는 배열 arr가 주어집니다. arr의 원소들을 순서대로 이어 붙인 문자열을 return 하는 solution함수를 작성해 주세요.제한사항  1 ≤ arr의 길이 ≤ 200          arr의 원소는 전부 알파벳 소문자로 이루어진 길이가 1인 문자열입니다.      입출력 예            arr      result                  [“a”,”b”,”c”]      “abc”      Solution  joined()라는 함수를 사용해 string들을 합칠 수 있습니다.import Foundationfunc solution(_ arr:[String]) -&gt; String {    return arr.joined()}"
  },
  
  {
    "title": "Basic11 문자열 섞기",
    "url": "/posts/ProgrammersBasic-11/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-12 00:00:00 +0900",
    





    
    "snippet": "11. 문자열 섞기문제 설명길이가 같은 두 문자열 str1과 str2가 주어집니다.두 문자열의 각 문자가 앞에서부터 서로 번갈아가면서 한 번씩 등장하는 문자열을 만들어 return 하는 solution 함수를 완성해 주세요.제한사항  1 ≤ str1의 길이 = str2의 길이 ≤ 10          str1과 str2는 알파벳 소문자로 이루어진 문자...",
    "content": "11. 문자열 섞기문제 설명길이가 같은 두 문자열 str1과 str2가 주어집니다.두 문자열의 각 문자가 앞에서부터 서로 번갈아가면서 한 번씩 등장하는 문자열을 만들어 return 하는 solution 함수를 완성해 주세요.제한사항  1 ≤ str1의 길이 = str2의 길이 ≤ 10          str1과 str2는 알파벳 소문자로 이루어진 문자열입니다.      입출력 예            str1      str2      result                  “aaaaa”      “bbbbb”      “ababababab”      Solution  이전 문제와 마찬가지로 Array로 변환한 후에 처리한 코드는 아래와 같습니다.import Foundationfunc solution(_ str1:String, _ str2:String) -&gt; String {    var result = [Character]()    var str1Array = Array(str1)    var str2Array = Array(str2)        for i in 0..&lt;str1.count {        result.append(str1Array[i])        result.append(str2Array[i])    }        return String(result)}  다른 방법으로는, 두 개의 시퀀스를 이용해서 시퀀스 쌍을 만들 수 있는 zip을 이용해서 문제를 풀 수 있습니다.func solution(_ str1:String, _ str2:String) -&gt; String {    var result = \"\"    for (a,b) in zip(str1, str2){        result.append(a)        result.append(b)    }    return result}"
  },
  
  {
    "title": "Basic10 문자열 겹쳐쓰기",
    "url": "/posts/ProgrammersBasic-10/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-12 00:00:00 +0900",
    





    
    "snippet": "10. 문자열 겹쳐쓰기문제 설명문자열 my_string, overwrite_string과 정수 s가 주어집니다. 문자열 my_string의 인덱스 s부터 overwrite_string의 길이만큼을 문자열 overwrite_string으로 바꾼 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  my_string와 overwrit...",
    "content": "10. 문자열 겹쳐쓰기문제 설명문자열 my_string, overwrite_string과 정수 s가 주어집니다. 문자열 my_string의 인덱스 s부터 overwrite_string의 길이만큼을 문자열 overwrite_string으로 바꾼 문자열을 return 하는 solution 함수를 작성해 주세요.제한사항  my_string와 overwrite_string은 숫자와 알파벳으로 이루어져 있습니다.  1 ≤ overwrite_string의 길이 ≤ my_string의 길이 ≤ 1,000  0 ≤ s ≤ my_string의 길이 - overwrite_string의 길이입출력 예            my_string      overwrite_string      s      result                  “He11oWor1d”      “lloWorl”      2      “HelloWorld”              “Program29b8UYP”      “merS123”      7      “ProgrammerS123”      입출력 예 설명입출력 예 #1  예제 1번의 my_string에서 인덱스 2부터 overwrite_string의 길이만큼에 해당하는 부분은 “11oWor1”이고 이를 “lloWorl”로 바꾼 “HelloWorld”를 return 합니다.입출력 예 #2  예제 2번의 my_string에서 인덱스 7부터 overwrite_string의 길이만큼에 해당하는 부분은 “29b8UYP”이고 이를 “merS123”로 바꾼 “ProgrammerS123”를 return 합니다.Solution  swift에서는 인덱스를 사용해서 String의 각 요소에 접근하는 방법이 안됩니다. (my_string[i] - error) 그래서 String을 Array로 변환하고, 필요한 작업을 처리한 후에 다시 String으로 변환해서 반환해주는 코드를 작성했습니다.import Foundationfunc solution(_ my_string:String, _ overwrite_string:String, _ s:Int) -&gt; String {    var my_array = Array(my_string)    var overwrite_array = Array(overwrite_string)    for i in s..&lt;overwrite_array.count + s {        my_array[i] = overwrite_array[i-s]    }    return String(my_array)}  또한 Array에는 replaceSubrange라는 내부함수가 있어서 이를 사용하는 방법도 있습니다.my_array.replaceSubrange(s...(overwrite_array.count+s-1), with: overwrite_string)"
  },
  
  {
    "title": "Basic9 홀짝 구분하기",
    "url": "/posts/ProgrammersBasic-9/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-12 00:00:00 +0900",
    





    
    "snippet": "9. 홀짝 구분하기문제 설명자연수 n이 입력으로 주어졌을 때 만약 n이 짝수이면 “n is even”을, 홀수이면 “n is odd”를 출력하는 코드를 작성해 보세요.제한사항  1 ≤ n ≤ 1,000입출력 예입력 #1100출력 #1100 is even입력 #21출력 #21 is oddSolutionimport Foundationlet a = Int(...",
    "content": "9. 홀짝 구분하기문제 설명자연수 n이 입력으로 주어졌을 때 만약 n이 짝수이면 “n is even”을, 홀수이면 “n is odd”를 출력하는 코드를 작성해 보세요.제한사항  1 ≤ n ≤ 1,000입출력 예입력 #1100출력 #1100 is even입력 #21출력 #21 is oddSolutionimport Foundationlet a = Int(readLine()!)!if a % 2 == 0 {    print(\"\\(a) is even\")} else {    print(\"\\(a) is odd\")}"
  },
  
  {
    "title": "Basic8 문자열 돌리기",
    "url": "/posts/ProgrammersBasic-8/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-11 00:00:00 +0900",
    





    
    "snippet": "8. 문자열 돌리기문제 설명문자열 str이 주어집니다.문자열을 시계방향으로 90도 돌려서 아래 입출력 예와 같이 출력하는 코드를 작성해 보세요.제한사항1 ≤ str의 길이 ≤ 10입출력 예입력 #1abcde출력 #1abcdeSolutionimport Foundationlet s1 = readLine()!s1.map {print($0)}",
    "content": "8. 문자열 돌리기문제 설명문자열 str이 주어집니다.문자열을 시계방향으로 90도 돌려서 아래 입출력 예와 같이 출력하는 코드를 작성해 보세요.제한사항1 ≤ str의 길이 ≤ 10입출력 예입력 #1abcde출력 #1abcdeSolutionimport Foundationlet s1 = readLine()!s1.map {print($0)}"
  },
  
  {
    "title": "Basic7 문자열 붙여서 출력하기",
    "url": "/posts/ProgrammersBasic-7/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-10 00:00:00 +0900",
    





    
    "snippet": "7. 문자열 붙여서 출력하기문제 설명두 개의 문자열 str1, str2가 공백으로 구분되어 입력으로 주어집니다.입출력 예와 같이 str1과 str2을 이어서 출력하는 코드를 작성해 보세요.제한사항  1 ≤ str1, str2의 길이 ≤ 10입출력 예입력 #1apple pen출력 #1applepen입력 #2Hello World!출력 #2HelloWorl...",
    "content": "7. 문자열 붙여서 출력하기문제 설명두 개의 문자열 str1, str2가 공백으로 구분되어 입력으로 주어집니다.입출력 예와 같이 str1과 str2을 이어서 출력하는 코드를 작성해 보세요.제한사항  1 ≤ str1, str2의 길이 ≤ 10입출력 예입력 #1apple pen출력 #1applepen입력 #2Hello World!출력 #2HelloWorld!Solutionimport Foundationlet inp = readLine()!.components(separatedBy: [\" \"]).map { $0 }let (s1, s2) = (inp[0], inp[1])print(s1+s2)  String은 '+' 연산자를 이용해서 붙일 수 있습니다."
  },
  
  {
    "title": "Basic6 덧셈식 출력하기",
    "url": "/posts/ProgrammersBasic-6/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-10 00:00:00 +0900",
    





    
    "snippet": "문제 설명두 정수 a, b가 주어질 때 다음과 같은 형태의 계산식을 출력하는 코드를 작성해 보세요.a + b = c제한사항  1 ≤ a, b ≤ 100입출력 예입력4 5출력4 + 5 = 9Solutionimport Foundationlet n = readLine()!.components(separatedBy: [\" \"]).map { Int($0)! }...",
    "content": "문제 설명두 정수 a, b가 주어질 때 다음과 같은 형태의 계산식을 출력하는 코드를 작성해 보세요.a + b = c제한사항  1 ≤ a, b ≤ 100입출력 예입력4 5출력4 + 5 = 9Solutionimport Foundationlet n = readLine()!.components(separatedBy: [\" \"]).map { Int($0)! }let (a, b) = (n[0], n[1])print(\"\\(a) + \\(b) = \\(a+b)\")"
  },
  
  {
    "title": "Basic4~5",
    "url": "/posts/ProgrammersBasic-4~5/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-10 00:00:00 +0900",
    





    
    "snippet": "4. 대소문자 바꿔서 출력하기문제 설명영어 알파벳으로 이루어진 문자열 str이 주어집니다. 각 알파벳을 대문자는 소문자로 소문자는 대문자로 변환해서 출력하는 코드를 작성해 보세요.제한사항  1 ≤ str의 길이 ≤ 20          str은 알파벳으로 이루어진 문자열입니다.      입출력 예입력aBcDeFg출력AbCdEfGSolutionimpor...",
    "content": "4. 대소문자 바꿔서 출력하기문제 설명영어 알파벳으로 이루어진 문자열 str이 주어집니다. 각 알파벳을 대문자는 소문자로 소문자는 대문자로 변환해서 출력하는 코드를 작성해 보세요.제한사항  1 ≤ str의 길이 ≤ 20          str은 알파벳으로 이루어진 문자열입니다.      입출력 예입력aBcDeFg출력AbCdEfGSolutionimport Foundationlet s1 = readLine()!let result = s1.map {$0.isLowercase ? $0.uppercased() : $0.lowercased()}.joined()print(result)5. 특수문자 출력하기문제 설명다음과 같이 출력하도록 코드를 작성해 주세요.출력 예시!@#$%^&amp;*(\\'\"&lt;&gt;?:;설명  양 끝에 #을 붙여주어야 합니다.Solutionimport Foundationprint(#\"!@#$%^&amp;*(\\'\"&lt;&gt;?:;\"#)"
  },
  
  {
    "title": "Basic1~3",
    "url": "/posts/ProgrammersBasic-1~3/",
    "categories": "Programmers, Basic_Swift",
    "tags": "Algorithm, SwiftAlgorithm",
    "date": "2024-01-09 00:00:00 +0900",
    





    
    "snippet": "1. 문자열 출력하기문제설명문자열 `str`이 주어질 때, `str`을 출력하는 코드를 작성해 보세요. ### 제한사항  1 ≤ str의 길이 ≤ 1,000,000  str에는 공백이 없으며, 첫째 줄에 한 줄로만 주어집니다.입출력 예시입력HelloWorld!출력HelloWorld!Solutionimport Foundationlet s1 = readL...",
    "content": "1. 문자열 출력하기문제설명문자열 `str`이 주어질 때, `str`을 출력하는 코드를 작성해 보세요. ### 제한사항  1 ≤ str의 길이 ≤ 1,000,000  str에는 공백이 없으며, 첫째 줄에 한 줄로만 주어집니다.입출력 예시입력HelloWorld!출력HelloWorld!Solutionimport Foundationlet s1 = readLine()!print(s1)2. a와 b 출력하기문제 설명정수 a와 b가 주어집니다. 각 수를 입력받아 입출력 예와 같은 형식으로 출력하는 코드를 작성해 보세요.제한사항  -100,000 ≤ a, b ≤ 100,000입출력 예입력4 5출력a = 4b = 5Solutionimport Foundationlet n = readLine()!.components(separatedBy: [\" \"]).map { Int($0)! }let (a, b) = (n[0], n[1])print(\"a = \\(a) \\nb = \\(b)\")3. 문자열 반복해서 출력하기문제 설명문자열 str과 정수 n이 주어집니다.str이 n번 반복된 문자열을 만들어 출력하는 코드를 작성해 보세요.제한사항  1 ≤ str의 길이 ≤ 10  1 ≤ n ≤ 5입출력 예입력string 5출력stringstringstringstringstringSolution일반적으로 반복문을 사용해서 해결하는 방법과, swift의 String에서 지원하는 repeating을 사용하는 방법 두가지가 있습니다.  반복문import Foundationlet inp = readLine()!.components(separatedBy: [\" \"]).map { $0 }let (s1, a) = (inp[0], Int(inp[1])!)var result = \"\"for _ in 0..&lt;a {    result += s1}print(result)  repeatingimport Foundationlet inp = readLine()!.components(separatedBy: [\" \"]).map { $0 }let (s1, a) = (inp[0], Int(inp[1])!)print(String(repeating: s1, count: a))"
  }
  
]

